{"ast":null,"code":"var _jsxFileName = \"/Users/eimis/test-server/react_projects/legendary-lines-game/src/random.js\",\n  _s = $RefreshSig$();\n/*\nThis code is a React component that displays a random image from a set of images stored in a Cloudinary account. \nThe component takes two props as input - cloud_name and tag - which are used to fetch a JSON list of image \nresources from Cloudinary's API. The component uses the useState and useEffect hooks to manage its state and \nfetch the list of image resources whenever the component is rendered.\n\nOnce the list of image resources is fetched, the component generates a random index to pick an image from the list.\nIt then stores the used index in a persistent array called usedIndexes to keep track of which images have already\nbeen displayed. If the array of used indexes fills up and every index has been used, it is emptied out, allowing\nall images to be displayed again. The selected image is displayed using the AdvancedImage component from the\n@cloudinary/react library, which takes a cldImg prop representing the selected image and an alt prop \nrepresenting the image's public ID.\n*/\n\n// import dependencies\nimport React, { useState, useEffect } from \"react\";\nimport { CloudinaryImage } from \"@cloudinary/url-gen\";\nimport { AdvancedImage } from \"@cloudinary/react\";\n\n// Create a persistent array to store used indices\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet usedIndexes = [];\nconst RandomImage = _ref => {\n  _s();\n  let {\n    cloud_name,\n    tag\n  } = _ref;\n  // Declare the state variable `image` and a function `setImage` to update it\n  const [image, setImage] = useState(null);\n\n  // The effect hook is executed when the component is first rendered and after any re-render caused by changes in the state\n  useEffect(() => {\n    const fetchData = async () => {\n      // Fetch the list of images from Cloudinary\n      const response = await fetch(\"https://res.cloudinary.com/\".concat(cloud_name, \"/image/list/\").concat(tag, \".json\"));\n      const data = await response.json();\n\n      // Generate a random index from the list of images\n      let randomIndex = Math.floor(Math.random() * data.resources.length);\n\n      // Check if this random index has already been used\n      while (usedIndexes.includes(randomIndex)) {\n        // If the random index has been used, generate a new random index\n        randomIndex = Math.floor(Math.random() * data.resources.length);\n\n        // When the array of used indexes fills up, empty it out\n        if (usedIndexes.length === data.resources.length - 1) {\n          usedIndexes = [];\n        }\n      }\n\n      // Store this new random index in the array of used indexes\n      usedIndexes.push(randomIndex);\n\n      // Set the state with the randomly selected image\n      const randomImage = data.resources[randomIndex];\n      setImage(randomImage);\n    };\n    fetchData();\n  }, [cloud_name, tag]);\n  if (image) {\n    // Create a new CloudinaryImage instance with the selected image and cloud name\n    const myImage = new CloudinaryImage(image.public_id, {\n      cloudName: \"\".concat(cloud_name)\n    });\n\n    // Set the alt attribute for the image\n    const altId = \"\".concat(image.public_id);\n    return /*#__PURE__*/_jsxDEV(AdvancedImage, {\n      cldImg: myImage,\n      alt: altId\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 68,\n      columnNumber: 12\n    }, this);\n  } else {\n    // Return null while the image is not yet fetched\n    return null;\n  }\n};\n\n// Export the RandomImage component\n_s(RandomImage, \"dGVwJEArO+c3odeDsBUMrBRJ/DQ=\");\n_c = RandomImage;\nexport default RandomImage;\nvar _c;\n$RefreshReg$(_c, \"RandomImage\");","map":{"version":3,"names":["React","useState","useEffect","CloudinaryImage","AdvancedImage","jsxDEV","_jsxDEV","usedIndexes","RandomImage","_ref","_s","cloud_name","tag","image","setImage","fetchData","response","fetch","concat","data","json","randomIndex","Math","floor","random","resources","length","includes","push","randomImage","myImage","public_id","cloudName","altId","cldImg","alt","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/eimis/test-server/react_projects/legendary-lines-game/src/random.js"],"sourcesContent":["/*\nThis code is a React component that displays a random image from a set of images stored in a Cloudinary account. \nThe component takes two props as input - cloud_name and tag - which are used to fetch a JSON list of image \nresources from Cloudinary's API. The component uses the useState and useEffect hooks to manage its state and \nfetch the list of image resources whenever the component is rendered.\n\nOnce the list of image resources is fetched, the component generates a random index to pick an image from the list.\nIt then stores the used index in a persistent array called usedIndexes to keep track of which images have already\nbeen displayed. If the array of used indexes fills up and every index has been used, it is emptied out, allowing\nall images to be displayed again. The selected image is displayed using the AdvancedImage component from the\n@cloudinary/react library, which takes a cldImg prop representing the selected image and an alt prop \nrepresenting the image's public ID.\n*/\n\n// import dependencies\nimport React, { useState, useEffect } from \"react\";\nimport { CloudinaryImage } from \"@cloudinary/url-gen\";\nimport { AdvancedImage } from \"@cloudinary/react\";\n\n// Create a persistent array to store used indices\nlet usedIndexes = [];\n\nconst RandomImage = ({ cloud_name, tag }) => {\n  // Declare the state variable `image` and a function `setImage` to update it\n  const [image, setImage] = useState(null);\n\n  // The effect hook is executed when the component is first rendered and after any re-render caused by changes in the state\n  useEffect(() => {\n    const fetchData = async () => {\n      // Fetch the list of images from Cloudinary\n      const response = await fetch(\n        `https://res.cloudinary.com/${cloud_name}/image/list/${tag}.json`\n      );\n      const data = await response.json();\n\n      // Generate a random index from the list of images\n      let randomIndex = Math.floor(Math.random() * data.resources.length);\n\n      // Check if this random index has already been used\n      while (usedIndexes.includes(randomIndex)) {\n        // If the random index has been used, generate a new random index\n        randomIndex = Math.floor(Math.random() * data.resources.length);\n\n        // When the array of used indexes fills up, empty it out\n        if (usedIndexes.length === data.resources.length - 1) {\n          usedIndexes = [];\n        }\n      }\n\n      // Store this new random index in the array of used indexes\n      usedIndexes.push(randomIndex);\n\n      // Set the state with the randomly selected image\n      const randomImage = data.resources[randomIndex];\n      setImage(randomImage);\n    };\n    fetchData();\n  }, [cloud_name, tag]);\n\n  if (image) {\n    // Create a new CloudinaryImage instance with the selected image and cloud name\n    const myImage = new CloudinaryImage(image.public_id, {\n      cloudName: `${cloud_name}`\n    });\n\n    // Set the alt attribute for the image\n    const altId = `${image.public_id}`;\n    return <AdvancedImage cldImg={myImage} alt={altId} />;\n  } else {\n    // Return null while the image is not yet fetched\n    return null;\n  }\n};\n\n// Export the RandomImage component\nexport default RandomImage;\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAClD,SAASC,eAAe,QAAQ,qBAAqB;AACrD,SAASC,aAAa,QAAQ,mBAAmB;;AAEjD;AAAA,SAAAC,MAAA,IAAAC,OAAA;AACA,IAAIC,WAAW,GAAG,EAAE;AAEpB,MAAMC,WAAW,GAAGC,IAAA,IAAyB;EAAAC,EAAA;EAAA,IAAxB;IAAEC,UAAU;IAAEC;EAAI,CAAC,GAAAH,IAAA;EACtC;EACA,MAAM,CAACI,KAAK,EAAEC,QAAQ,CAAC,GAAGb,QAAQ,CAAC,IAAI,CAAC;;EAExC;EACAC,SAAS,CAAC,MAAM;IACd,MAAMa,SAAS,GAAG,MAAAA,CAAA,KAAY;MAC5B;MACA,MAAMC,QAAQ,GAAG,MAAMC,KAAK,+BAAAC,MAAA,CACIP,UAAU,kBAAAO,MAAA,CAAeN,GAAG,UAC5D,CAAC;MACD,MAAMO,IAAI,GAAG,MAAMH,QAAQ,CAACI,IAAI,CAAC,CAAC;;MAElC;MACA,IAAIC,WAAW,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGL,IAAI,CAACM,SAAS,CAACC,MAAM,CAAC;;MAEnE;MACA,OAAOnB,WAAW,CAACoB,QAAQ,CAACN,WAAW,CAAC,EAAE;QACxC;QACAA,WAAW,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGL,IAAI,CAACM,SAAS,CAACC,MAAM,CAAC;;QAE/D;QACA,IAAInB,WAAW,CAACmB,MAAM,KAAKP,IAAI,CAACM,SAAS,CAACC,MAAM,GAAG,CAAC,EAAE;UACpDnB,WAAW,GAAG,EAAE;QAClB;MACF;;MAEA;MACAA,WAAW,CAACqB,IAAI,CAACP,WAAW,CAAC;;MAE7B;MACA,MAAMQ,WAAW,GAAGV,IAAI,CAACM,SAAS,CAACJ,WAAW,CAAC;MAC/CP,QAAQ,CAACe,WAAW,CAAC;IACvB,CAAC;IACDd,SAAS,CAAC,CAAC;EACb,CAAC,EAAE,CAACJ,UAAU,EAAEC,GAAG,CAAC,CAAC;EAErB,IAAIC,KAAK,EAAE;IACT;IACA,MAAMiB,OAAO,GAAG,IAAI3B,eAAe,CAACU,KAAK,CAACkB,SAAS,EAAE;MACnDC,SAAS,KAAAd,MAAA,CAAKP,UAAU;IAC1B,CAAC,CAAC;;IAEF;IACA,MAAMsB,KAAK,MAAAf,MAAA,CAAML,KAAK,CAACkB,SAAS,CAAE;IAClC,oBAAOzB,OAAA,CAACF,aAAa;MAAC8B,MAAM,EAAEJ,OAAQ;MAACK,GAAG,EAAEF;IAAM;MAAAG,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE,CAAC;EACvD,CAAC,MAAM;IACL;IACA,OAAO,IAAI;EACb;AACF,CAAC;;AAED;AAAA7B,EAAA,CApDMF,WAAW;AAAAgC,EAAA,GAAXhC,WAAW;AAqDjB,eAAeA,WAAW;AAAC,IAAAgC,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}