{"ast":null,"code":"import _objectSpread from \"/Users/eimis/test-server/react_projects/cloud-architecture-game/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport OpenAI from 'openai';\nconst openai = new OpenAI({\n  apiKey: process.env.REACT_APP_OPENAI_API_KEY\n});\nconst DIFFICULTY_MODIFIERS = {\n  EASY: {\n    description: \"well-known and popular quotes from the last 30 years\",\n    popularity: \"highly popular\",\n    maxRetries: 3,\n    temperature: 0.5\n  },\n  MEDIUM: {\n    description: \"moderately known quotes from the last 50 years\",\n    popularity: \"moderately known\",\n    maxRetries: 3,\n    temperature: 0.7\n  },\n  HARD: {\n    description: \"obscure or historical quotes from any time period\",\n    popularity: \"less known\",\n    maxRetries: 3,\n    temperature: 0.9\n  }\n};\n\n// Enhanced error types\nconst ERROR_TYPES = {\n  API_KEY: 'API_KEY_ERROR',\n  RATE_LIMIT: 'RATE_LIMIT_ERROR',\n  NETWORK: 'NETWORK_ERROR',\n  VALIDATION: 'VALIDATION_ERROR',\n  TIMEOUT: 'TIMEOUT_ERROR',\n  SERVER: 'SERVER_ERROR',\n  CONTENT_FILTER: 'CONTENT_FILTER_ERROR',\n  QUOTA_EXCEEDED: 'QUOTA_EXCEEDED_ERROR',\n  UNKNOWN: 'UNKNOWN_ERROR'\n};\n\n// Error tracking analytics\nconst errorStats = {\n  counts: {},\n  lastOccurrence: {},\n  retrySuccess: {}\n};\n\n// Sophisticated retry configuration\nconst RETRY_CONFIG = {\n  baseDelay: 1000,\n  maxRetries: 3,\n  timeoutMs: 10000,\n  backoffMultiplier: 1.5,\n  jitterMax: 200,\n  retryableStatuses: [429, 503, 502, 500]\n};\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// Add jitter to avoid thundering herd problem\nconst getJitter = () => Math.random() * RETRY_CONFIG.jitterMax;\n\n// Enhanced error classification\nconst classifyError = error => {\n  var _error$response, _error$response2, _error$response3;\n  // Log error for debugging\n  console.debug('Error details:', {\n    message: error.message,\n    status: (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status,\n    type: error.type,\n    stack: error.stack\n  });\n  if (error.message.includes('API key')) return ERROR_TYPES.API_KEY;\n  if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 429) return ERROR_TYPES.RATE_LIMIT;\n  if (error.message.includes('network')) return ERROR_TYPES.NETWORK;\n  if (error.message.includes('timeout')) return ERROR_TYPES.TIMEOUT;\n  if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) >= 500) return ERROR_TYPES.SERVER;\n  if (error.message.includes('content filter')) return ERROR_TYPES.CONTENT_FILTER;\n  if (error.message.includes('quota')) return ERROR_TYPES.QUOTA_EXCEEDED;\n  if (error.message.includes('Invalid API response')) return ERROR_TYPES.VALIDATION;\n  return ERROR_TYPES.UNKNOWN;\n};\n\n// Error logging with timestamp and context\nconst logError = function (error) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const errorType = classifyError(error);\n  const timestamp = new Date().toISOString();\n\n  // Update error statistics\n  errorStats.counts[errorType] = (errorStats.counts[errorType] || 0) + 1;\n  errorStats.lastOccurrence[errorType] = timestamp;\n\n  // Log to console with structured format\n  console.error('Game Error:', {\n    type: errorType,\n    timestamp,\n    message: error.message,\n    context,\n    stats: errorStats.counts[errorType],\n    stack: error.stack\n  });\n\n  // Could be extended to send to external error tracking service\n  if (process.env.REACT_APP_ERROR_TRACKING_ENABLED === 'true') {\n    // Example: sendToErrorTracking(error, context);\n  }\n};\n\n// Sophisticated retry strategy with exponential backoff and jitter\nconst calculateRetryDelay = attempt => {\n  const exponentialDelay = RETRY_CONFIG.baseDelay * Math.pow(RETRY_CONFIG.backoffMultiplier, attempt);\n  return exponentialDelay + getJitter();\n};\n\n// Enhanced error handling with retry strategy\nexport const handleAPIError = async function (error) {\n  let retryCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const errorType = classifyError(error);\n  logError(error, _objectSpread(_objectSpread({}, context), {}, {\n    retryCount\n  }));\n\n  // Check if we've exceeded max retries\n  if (retryCount >= RETRY_CONFIG.maxRetries) {\n    throw new Error(\"Maximum retry attempts (\".concat(RETRY_CONFIG.maxRetries, \") exceeded.\"));\n  }\n\n  // Determine retry strategy based on error type\n  switch (errorType) {\n    case ERROR_TYPES.RATE_LIMIT:\n    case ERROR_TYPES.NETWORK:\n    case ERROR_TYPES.SERVER:\n      const delay = calculateRetryDelay(retryCount);\n      await sleep(delay);\n      errorStats.retrySuccess[errorType] = (errorStats.retrySuccess[errorType] || 0) + 1;\n      return {\n        shouldRetry: true,\n        delay,\n        errorType,\n        retryCount: retryCount + 1\n      };\n    case ERROR_TYPES.TIMEOUT:\n      if (retryCount < 2) {\n        const timeoutDelay = RETRY_CONFIG.baseDelay;\n        await sleep(timeoutDelay);\n        return {\n          shouldRetry: true,\n          delay: timeoutDelay,\n          errorType,\n          retryCount: retryCount + 1\n        };\n      }\n      throw new Error('Request timeout. Please try again.');\n    case ERROR_TYPES.VALIDATION:\n      if (retryCount < 1) {\n        return {\n          shouldRetry: true,\n          delay: 0,\n          errorType,\n          retryCount: retryCount + 1\n        };\n      }\n      throw new Error('Unable to generate valid content. Please try a different category.');\n    case ERROR_TYPES.CONTENT_FILTER:\n      throw new Error('Content was filtered. Please try a different phrase.');\n    case ERROR_TYPES.QUOTA_EXCEEDED:\n      throw new Error('API quota exceeded. Please try again later.');\n    case ERROR_TYPES.API_KEY:\n      throw new Error('Invalid API configuration. Please contact support.');\n    default:\n      throw new Error('An unexpected error occurred. Please try again.');\n  }\n};\n\n// Export error statistics for monitoring\nexport const getErrorStats = () => _objectSpread(_objectSpread({}, errorStats), {}, {\n  timestamp: new Date().toISOString()\n});\n\n// Export error types for external use\nexport const ERROR_TYPES_ENUM = ERROR_TYPES;\nexport const getPhrase = async function (category) {\n  let difficulty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'MEDIUM';\n  const difficultyConfig = DIFFICULTY_MODIFIERS[difficulty];\n  const operation = async () => {\n    try {\n      const systemPrompt = \"You are a game master for 'Legendary Lines'. \\n        Generate \".concat(difficultyConfig.popularity, \" content for the \").concat(category, \" category.\\n        Focus on \").concat(difficultyConfig.description, \".\");\n      const prompt = \"Generate a \".concat(difficulty.toLowerCase(), \" difficulty \").concat(category.toLowerCase(), \" quote or phrase.\\n        The response must be in this exact JSON format:\\n        {\\n          \\\"phrase\\\": \\\"the actual quote or phrase\\\",\\n          \\\"source\\\": \\\"where it's from\\\",\\n          \\\"year\\\": YYYY,\\n          \\\"hint\\\": \\\"a subtle hint without giving away the answer\\\",\\n          \\\"difficulty\\\": \\\"\").concat(difficulty, \"\\\",\\n          \\\"category\\\": \\\"\").concat(category, \"\\\"\\n        }\");\n      const completion = await openai.chat.completions.create({\n        messages: [{\n          role: \"system\",\n          content: systemPrompt\n        }, {\n          role: \"user\",\n          content: prompt\n        }],\n        model: \"gpt-4\",\n        temperature: difficultyConfig.temperature\n      });\n      const response = JSON.parse(completion.choices[0].message.content);\n\n      // Validate response format\n      const requiredFields = ['phrase', 'source', 'year', 'hint', 'difficulty', 'category'];\n      for (const field of requiredFields) {\n        if (!response[field]) {\n          throw new Error(\"Invalid API response: missing \".concat(field));\n        }\n      }\n      return response;\n    } catch (error) {\n      if (error.message.includes('Invalid API response')) {\n        throw new Error('Failed to generate valid phrase. Please try again.');\n      }\n      throw error;\n    }\n  };\n  return retryWithExponentialBackoff(operation, difficultyConfig.maxRetries);\n};\nexport const checkAnswer = async (userAnswer, correctAnswer, category) => {\n  const operation = async () => {\n    try {\n      const systemPrompt = \"You are an answer validator for the 'Legendary Lines' game.\";\n      const prompt = \"Compare these answers for a \".concat(category, \" quote:\\n        User's answer: \\\"\").concat(userAnswer, \"\\\"\\n        Correct answer: \\\"\").concat(correctAnswer.source, \"\\\"\\n        Difficulty level: \").concat(correctAnswer.difficulty, \"\\n        \\n        Consider variations in naming and common abbreviations.\\n        For harder difficulty levels, be more lenient with partial matches.\\n        Return a JSON response in this format:\\n        {\\n          \\\"isCorrect\\\": boolean,\\n          \\\"explanation\\\": \\\"brief explanation of why it's correct or incorrect\\\",\\n          \\\"similarity\\\": \\\"percentage of similarity\\\",\\n          \\\"partialCredit\\\": \\\"percentage of points to award for close answers (0-100)\\\"\\n        }\");\n      const completion = await openai.chat.completions.create({\n        messages: [{\n          role: \"system\",\n          content: systemPrompt\n        }, {\n          role: \"user\",\n          content: prompt\n        }],\n        model: \"gpt-4\",\n        temperature: 0.1\n      });\n      return JSON.parse(completion.choices[0].message.content);\n    } catch (error) {\n      throw new Error('Failed to validate answer. Please try again.');\n    }\n  };\n  return retryWithExponentialBackoff(operation);\n};","map":{"version":3,"names":["OpenAI","openai","apiKey","process","env","REACT_APP_OPENAI_API_KEY","DIFFICULTY_MODIFIERS","EASY","description","popularity","maxRetries","temperature","MEDIUM","HARD","ERROR_TYPES","API_KEY","RATE_LIMIT","NETWORK","VALIDATION","TIMEOUT","SERVER","CONTENT_FILTER","QUOTA_EXCEEDED","UNKNOWN","errorStats","counts","lastOccurrence","retrySuccess","RETRY_CONFIG","baseDelay","timeoutMs","backoffMultiplier","jitterMax","retryableStatuses","sleep","ms","Promise","resolve","setTimeout","getJitter","Math","random","classifyError","error","_error$response","_error$response2","_error$response3","console","debug","message","status","response","type","stack","includes","logError","context","arguments","length","undefined","errorType","timestamp","Date","toISOString","stats","REACT_APP_ERROR_TRACKING_ENABLED","calculateRetryDelay","attempt","exponentialDelay","pow","handleAPIError","retryCount","_objectSpread","Error","concat","delay","shouldRetry","timeoutDelay","getErrorStats","ERROR_TYPES_ENUM","getPhrase","category","difficulty","difficultyConfig","operation","systemPrompt","prompt","toLowerCase","completion","chat","completions","create","messages","role","content","model","JSON","parse","choices","requiredFields","field","retryWithExponentialBackoff","checkAnswer","userAnswer","correctAnswer","source"],"sources":["/Users/eimis/test-server/react_projects/cloud-architecture-game/src/services/aiService.js"],"sourcesContent":["import OpenAI from 'openai';\n\nconst openai = new OpenAI({\n  apiKey: process.env.REACT_APP_OPENAI_API_KEY,\n});\n\nconst DIFFICULTY_MODIFIERS = {\n  EASY: {\n    description: \"well-known and popular quotes from the last 30 years\",\n    popularity: \"highly popular\",\n    maxRetries: 3,\n    temperature: 0.5\n  },\n  MEDIUM: {\n    description: \"moderately known quotes from the last 50 years\",\n    popularity: \"moderately known\",\n    maxRetries: 3,\n    temperature: 0.7\n  },\n  HARD: {\n    description: \"obscure or historical quotes from any time period\",\n    popularity: \"less known\",\n    maxRetries: 3,\n    temperature: 0.9\n  }\n};\n\n// Enhanced error types\nconst ERROR_TYPES = {\n  API_KEY: 'API_KEY_ERROR',\n  RATE_LIMIT: 'RATE_LIMIT_ERROR',\n  NETWORK: 'NETWORK_ERROR',\n  VALIDATION: 'VALIDATION_ERROR',\n  TIMEOUT: 'TIMEOUT_ERROR',\n  SERVER: 'SERVER_ERROR',\n  CONTENT_FILTER: 'CONTENT_FILTER_ERROR',\n  QUOTA_EXCEEDED: 'QUOTA_EXCEEDED_ERROR',\n  UNKNOWN: 'UNKNOWN_ERROR'\n};\n\n// Error tracking analytics\nconst errorStats = {\n  counts: {},\n  lastOccurrence: {},\n  retrySuccess: {},\n};\n\n// Sophisticated retry configuration\nconst RETRY_CONFIG = {\n  baseDelay: 1000,\n  maxRetries: 3,\n  timeoutMs: 10000,\n  backoffMultiplier: 1.5,\n  jitterMax: 200,\n  retryableStatuses: [429, 503, 502, 500],\n};\n\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n// Add jitter to avoid thundering herd problem\nconst getJitter = () => Math.random() * RETRY_CONFIG.jitterMax;\n\n// Enhanced error classification\nconst classifyError = (error) => {\n  // Log error for debugging\n  console.debug('Error details:', {\n    message: error.message,\n    status: error.response?.status,\n    type: error.type,\n    stack: error.stack,\n  });\n\n  if (error.message.includes('API key')) return ERROR_TYPES.API_KEY;\n  if (error.response?.status === 429) return ERROR_TYPES.RATE_LIMIT;\n  if (error.message.includes('network')) return ERROR_TYPES.NETWORK;\n  if (error.message.includes('timeout')) return ERROR_TYPES.TIMEOUT;\n  if (error.response?.status >= 500) return ERROR_TYPES.SERVER;\n  if (error.message.includes('content filter')) return ERROR_TYPES.CONTENT_FILTER;\n  if (error.message.includes('quota')) return ERROR_TYPES.QUOTA_EXCEEDED;\n  if (error.message.includes('Invalid API response')) return ERROR_TYPES.VALIDATION;\n  return ERROR_TYPES.UNKNOWN;\n};\n\n// Error logging with timestamp and context\nconst logError = (error, context = {}) => {\n  const errorType = classifyError(error);\n  const timestamp = new Date().toISOString();\n  \n  // Update error statistics\n  errorStats.counts[errorType] = (errorStats.counts[errorType] || 0) + 1;\n  errorStats.lastOccurrence[errorType] = timestamp;\n\n  // Log to console with structured format\n  console.error('Game Error:', {\n    type: errorType,\n    timestamp,\n    message: error.message,\n    context,\n    stats: errorStats.counts[errorType],\n    stack: error.stack,\n  });\n\n  // Could be extended to send to external error tracking service\n  if (process.env.REACT_APP_ERROR_TRACKING_ENABLED === 'true') {\n    // Example: sendToErrorTracking(error, context);\n  }\n};\n\n// Sophisticated retry strategy with exponential backoff and jitter\nconst calculateRetryDelay = (attempt) => {\n  const exponentialDelay = RETRY_CONFIG.baseDelay * Math.pow(RETRY_CONFIG.backoffMultiplier, attempt);\n  return exponentialDelay + getJitter();\n};\n\n// Enhanced error handling with retry strategy\nexport const handleAPIError = async (error, retryCount = 0, context = {}) => {\n  const errorType = classifyError(error);\n  logError(error, { ...context, retryCount });\n\n  // Check if we've exceeded max retries\n  if (retryCount >= RETRY_CONFIG.maxRetries) {\n    throw new Error(`Maximum retry attempts (${RETRY_CONFIG.maxRetries}) exceeded.`);\n  }\n\n  // Determine retry strategy based on error type\n  switch (errorType) {\n    case ERROR_TYPES.RATE_LIMIT:\n    case ERROR_TYPES.NETWORK:\n    case ERROR_TYPES.SERVER:\n      const delay = calculateRetryDelay(retryCount);\n      await sleep(delay);\n      errorStats.retrySuccess[errorType] = (errorStats.retrySuccess[errorType] || 0) + 1;\n      return { \n        shouldRetry: true, \n        delay,\n        errorType,\n        retryCount: retryCount + 1\n      };\n\n    case ERROR_TYPES.TIMEOUT:\n      if (retryCount < 2) {\n        const timeoutDelay = RETRY_CONFIG.baseDelay;\n        await sleep(timeoutDelay);\n        return { \n          shouldRetry: true, \n          delay: timeoutDelay,\n          errorType,\n          retryCount: retryCount + 1\n        };\n      }\n      throw new Error('Request timeout. Please try again.');\n\n    case ERROR_TYPES.VALIDATION:\n      if (retryCount < 1) {\n        return { \n          shouldRetry: true, \n          delay: 0,\n          errorType,\n          retryCount: retryCount + 1\n        };\n      }\n      throw new Error('Unable to generate valid content. Please try a different category.');\n\n    case ERROR_TYPES.CONTENT_FILTER:\n      throw new Error('Content was filtered. Please try a different phrase.');\n\n    case ERROR_TYPES.QUOTA_EXCEEDED:\n      throw new Error('API quota exceeded. Please try again later.');\n\n    case ERROR_TYPES.API_KEY:\n      throw new Error('Invalid API configuration. Please contact support.');\n\n    default:\n      throw new Error('An unexpected error occurred. Please try again.');\n  }\n};\n\n// Export error statistics for monitoring\nexport const getErrorStats = () => ({\n  ...errorStats,\n  timestamp: new Date().toISOString(),\n});\n\n// Export error types for external use\nexport const ERROR_TYPES_ENUM = ERROR_TYPES;\n\nexport const getPhrase = async (category, difficulty = 'MEDIUM') => {\n  const difficultyConfig = DIFFICULTY_MODIFIERS[difficulty];\n  \n  const operation = async () => {\n    try {\n      const systemPrompt = `You are a game master for 'Legendary Lines'. \n        Generate ${difficultyConfig.popularity} content for the ${category} category.\n        Focus on ${difficultyConfig.description}.`;\n      \n      const prompt = `Generate a ${difficulty.toLowerCase()} difficulty ${category.toLowerCase()} quote or phrase.\n        The response must be in this exact JSON format:\n        {\n          \"phrase\": \"the actual quote or phrase\",\n          \"source\": \"where it's from\",\n          \"year\": YYYY,\n          \"hint\": \"a subtle hint without giving away the answer\",\n          \"difficulty\": \"${difficulty}\",\n          \"category\": \"${category}\"\n        }`;\n\n      const completion = await openai.chat.completions.create({\n        messages: [\n          { role: \"system\", content: systemPrompt },\n          { role: \"user\", content: prompt }\n        ],\n        model: \"gpt-4\",\n        temperature: difficultyConfig.temperature,\n      });\n\n      const response = JSON.parse(completion.choices[0].message.content);\n      \n      // Validate response format\n      const requiredFields = ['phrase', 'source', 'year', 'hint', 'difficulty', 'category'];\n      for (const field of requiredFields) {\n        if (!response[field]) {\n          throw new Error(`Invalid API response: missing ${field}`);\n        }\n      }\n\n      return response;\n    } catch (error) {\n      if (error.message.includes('Invalid API response')) {\n        throw new Error('Failed to generate valid phrase. Please try again.');\n      }\n      throw error;\n    }\n  };\n\n  return retryWithExponentialBackoff(\n    operation,\n    difficultyConfig.maxRetries\n  );\n};\n\nexport const checkAnswer = async (userAnswer, correctAnswer, category) => {\n  const operation = async () => {\n    try {\n      const systemPrompt = `You are an answer validator for the 'Legendary Lines' game.`;\n      \n      const prompt = `Compare these answers for a ${category} quote:\n        User's answer: \"${userAnswer}\"\n        Correct answer: \"${correctAnswer.source}\"\n        Difficulty level: ${correctAnswer.difficulty}\n        \n        Consider variations in naming and common abbreviations.\n        For harder difficulty levels, be more lenient with partial matches.\n        Return a JSON response in this format:\n        {\n          \"isCorrect\": boolean,\n          \"explanation\": \"brief explanation of why it's correct or incorrect\",\n          \"similarity\": \"percentage of similarity\",\n          \"partialCredit\": \"percentage of points to award for close answers (0-100)\"\n        }`;\n\n      const completion = await openai.chat.completions.create({\n        messages: [\n          { role: \"system\", content: systemPrompt },\n          { role: \"user\", content: prompt }\n        ],\n        model: \"gpt-4\",\n        temperature: 0.1,\n      });\n\n      return JSON.parse(completion.choices[0].message.content);\n    } catch (error) {\n      throw new Error('Failed to validate answer. Please try again.');\n    }\n  };\n\n  return retryWithExponentialBackoff(operation);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}