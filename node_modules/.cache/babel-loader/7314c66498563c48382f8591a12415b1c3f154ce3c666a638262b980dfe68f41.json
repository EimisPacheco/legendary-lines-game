{"ast":null,"code":"import _objectSpread from \"/Users/eimis/test-server/react_projects/cloud-architecture-game/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport OpenAI from 'openai';\n\n// Debug mode configuration\nconst DEBUG = {\n  enabled: process.env.REACT_APP_DEBUG_MODE === 'true',\n  verbose: process.env.REACT_APP_DEBUG_VERBOSE === 'true',\n  logLevel: process.env.REACT_APP_DEBUG_LEVEL || 'info',\n  retrySimulation: process.env.REACT_APP_SIMULATE_RETRIES === 'true'\n};\n\n// Enhanced retry patterns\nconst RETRY_PATTERNS = {\n  AGGRESSIVE: {\n    maxRetries: 5,\n    baseDelay: 500,\n    backoffMultiplier: 1.2,\n    jitterMax: 100,\n    timeout: 8000\n  },\n  CONSERVATIVE: {\n    maxRetries: 3,\n    baseDelay: 1000,\n    backoffMultiplier: 2,\n    jitterMax: 200,\n    timeout: 15000\n  },\n  ADAPTIVE: {\n    initialMaxRetries: 3,\n    maxRetriesLimit: 7,\n    baseDelay: 800,\n    successThreshold: 0.7,\n    failureThreshold: 0.3,\n    adaptiveWindow: 10 // Number of requests to consider for adaptation\n  }\n};\n\n// Retry history for adaptive pattern\nconst retryHistory = {\n  attempts: [],\n  successes: 0,\n  failures: 0\n};\nconst debugLog = function (level, message) {\n  let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!DEBUG.enabled) return;\n  const timestamp = new Date().toISOString();\n  const logLevels = ['error', 'warn', 'info', 'debug'];\n  if (logLevels.indexOf(level) <= logLevels.indexOf(DEBUG.logLevel)) {\n    console[level](\"[\".concat(timestamp, \"] \").concat(message), _objectSpread(_objectSpread({}, data), {}, {\n      debugMode: true,\n      logLevel: level\n    }));\n  }\n};\n\n// Adaptive retry strategy\nconst updateRetryStrategy = () => {\n  if (retryHistory.attempts.length < RETRY_PATTERNS.ADAPTIVE.adaptiveWindow) {\n    return RETRY_PATTERNS.CONSERVATIVE;\n  }\n  const recentAttempts = retryHistory.attempts.slice(-RETRY_PATTERNS.ADAPTIVE.adaptiveWindow);\n  const successRate = recentAttempts.filter(a => a.success).length / recentAttempts.length;\n  debugLog('info', 'Updating retry strategy', {\n    successRate,\n    recentAttempts\n  });\n  if (successRate > RETRY_PATTERNS.ADAPTIVE.successThreshold) {\n    return _objectSpread(_objectSpread({}, RETRY_PATTERNS.CONSERVATIVE), {}, {\n      maxRetries: Math.max(2, RETRY_PATTERNS.CONSERVATIVE.maxRetries - 1)\n    });\n  } else if (successRate < RETRY_PATTERNS.ADAPTIVE.failureThreshold) {\n    return _objectSpread(_objectSpread({}, RETRY_PATTERNS.AGGRESSIVE), {}, {\n      maxRetries: Math.min(RETRY_PATTERNS.ADAPTIVE.maxRetriesLimit, RETRY_PATTERNS.AGGRESSIVE.maxRetries + 1)\n    });\n  }\n  return RETRY_PATTERNS.CONSERVATIVE;\n};\n\n// Circuit breaker implementation\nconst circuitBreaker = {\n  failures: 0,\n  lastFailure: null,\n  threshold: 5,\n  resetTimeout: 30000,\n  isOpen() {\n    if (!this.lastFailure) return false;\n    const timeSinceLastFailure = Date.now() - this.lastFailure;\n    return this.failures >= this.threshold && timeSinceLastFailure < this.resetTimeout;\n  },\n  recordFailure() {\n    this.failures++;\n    this.lastFailure = Date.now();\n    debugLog('warn', 'Circuit breaker failure recorded', {\n      failures: this.failures,\n      threshold: this.threshold\n    });\n  },\n  reset() {\n    this.failures = 0;\n    this.lastFailure = null;\n    debugLog('info', 'Circuit breaker reset');\n  }\n};\nconst openai = new OpenAI({\n  apiKey: process.env.REACT_APP_OPENAI_API_KEY,\n  dangerouslyAllowBrowser: true\n});\nconst DIFFICULTY_MODIFIERS = {\n  EASY: {\n    description: \"well-known and popular quotes from the last 30 years\",\n    popularity: \"highly popular\",\n    maxRetries: 3,\n    temperature: 0.5\n  },\n  MEDIUM: {\n    description: \"moderately known quotes from the last 50 years\",\n    popularity: \"moderately known\",\n    maxRetries: 3,\n    temperature: 0.7\n  },\n  HARD: {\n    description: \"obscure or historical quotes from any time period\",\n    popularity: \"less known\",\n    maxRetries: 3,\n    temperature: 0.9\n  }\n};\n\n// Enhanced error types\nconst ERROR_TYPES = {\n  API_KEY: 'API_KEY_ERROR',\n  RATE_LIMIT: 'RATE_LIMIT_ERROR',\n  NETWORK: 'NETWORK_ERROR',\n  VALIDATION: 'VALIDATION_ERROR',\n  TIMEOUT: 'TIMEOUT_ERROR',\n  SERVER: 'SERVER_ERROR',\n  CONTENT_FILTER: 'CONTENT_FILTER_ERROR',\n  QUOTA_EXCEEDED: 'QUOTA_EXCEEDED_ERROR',\n  UNKNOWN: 'UNKNOWN_ERROR'\n};\n\n// Error tracking analytics\nconst errorStats = {\n  counts: {},\n  lastOccurrence: {},\n  retrySuccess: {}\n};\n\n// Sophisticated retry configuration\nconst RETRY_CONFIG = {\n  baseDelay: 1000,\n  maxRetries: 3,\n  timeoutMs: 10000,\n  backoffMultiplier: 1.5,\n  jitterMax: 200,\n  retryableStatuses: [429, 503, 502, 500]\n};\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// Add jitter to avoid thundering herd problem\nconst getJitter = () => Math.random() * RETRY_CONFIG.jitterMax;\n\n// Enhanced error classification\nconst classifyError = error => {\n  var _error$response, _error$response2, _error$response3;\n  // Log error for debugging\n  console.debug('Error details:', {\n    message: error.message,\n    status: (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status,\n    type: error.type,\n    stack: error.stack\n  });\n  if (error.message.includes('API key')) return ERROR_TYPES.API_KEY;\n  if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 429) return ERROR_TYPES.RATE_LIMIT;\n  if (error.message.includes('network')) return ERROR_TYPES.NETWORK;\n  if (error.message.includes('timeout')) return ERROR_TYPES.TIMEOUT;\n  if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) >= 500) return ERROR_TYPES.SERVER;\n  if (error.message.includes('content filter')) return ERROR_TYPES.CONTENT_FILTER;\n  if (error.message.includes('quota')) return ERROR_TYPES.QUOTA_EXCEEDED;\n  if (error.message.includes('Invalid API response')) return ERROR_TYPES.VALIDATION;\n  return ERROR_TYPES.UNKNOWN;\n};\n\n// Error logging with timestamp and context\nconst logError = function (error) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const errorType = classifyError(error);\n  const timestamp = new Date().toISOString();\n\n  // Update error statistics\n  errorStats.counts[errorType] = (errorStats.counts[errorType] || 0) + 1;\n  errorStats.lastOccurrence[errorType] = timestamp;\n\n  // Log to console with structured format\n  console.error('Game Error:', {\n    type: errorType,\n    timestamp,\n    message: error.message,\n    context,\n    stats: errorStats.counts[errorType],\n    stack: error.stack\n  });\n\n  // Could be extended to send to external error tracking service\n  if (process.env.REACT_APP_ERROR_TRACKING_ENABLED === 'true') {\n    // Example: sendToErrorTracking(error, context);\n  }\n};\n\n// Sophisticated retry strategy with exponential backoff and jitter\nconst calculateRetryDelay = attempt => {\n  const exponentialDelay = RETRY_CONFIG.baseDelay * Math.pow(RETRY_CONFIG.backoffMultiplier, attempt);\n  return exponentialDelay + getJitter();\n};\n\n// Enhanced error handling with retry strategy\nexport const handleAPIError = async function (error) {\n  let retryCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (DEBUG.enabled) {\n    debugLog('error', 'API Error occurred', {\n      error,\n      retryCount,\n      context\n    });\n  }\n\n  // Check circuit breaker\n  if (circuitBreaker.isOpen()) {\n    throw new Error('Service temporarily unavailable. Please try again later.');\n  }\n  const errorType = classifyError(error);\n  const retryPattern = updateRetryStrategy();\n  if (DEBUG.retrySimulation) {\n    debugLog('info', 'Simulating retry scenario', {\n      errorType,\n      retryPattern\n    });\n  }\n  try {\n    // ... existing error handling logic ...\n\n    // Record success in retry history\n    retryHistory.attempts.push({\n      success: true,\n      timestamp: Date.now()\n    });\n    circuitBreaker.reset();\n    return {\n      shouldRetry: true,\n      delay: calculateRetryDelay(retryCount, retryPattern),\n      errorType,\n      retryCount: retryCount + 1,\n      retryPattern: retryPattern.name\n    };\n  } catch (err) {\n    // Record failure in retry history\n    retryHistory.attempts.push({\n      success: false,\n      timestamp: Date.now()\n    });\n    circuitBreaker.recordFailure();\n    if (DEBUG.enabled) {\n      debugLog('error', 'Retry attempt failed', {\n        attempt: retryCount + 1,\n        maxRetries: retryPattern.maxRetries,\n        error: err\n      });\n    }\n    throw err;\n  }\n};\n\n// Export error statistics for monitoring\nexport const getErrorStats = () => _objectSpread(_objectSpread({}, errorStats), {}, {\n  timestamp: new Date().toISOString()\n});\n\n// Export error types for external use\nexport const ERROR_TYPES_ENUM = ERROR_TYPES;\nconst retryWithExponentialBackoff = async function (operation) {\n  let maxRetries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  let baseDelay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n  let lastError;\n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      var _error$response4, _error$response5;\n      lastError = error;\n      if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 429 || ((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : _error$response5.status) === 503) {\n        const delay = baseDelay * Math.pow(2, attempt);\n        console.log(\"Attempt \".concat(attempt + 1, \" failed, retrying in \").concat(delay, \"ms...\"));\n        await sleep(delay);\n        continue;\n      }\n      throw error;\n    }\n  }\n  throw lastError;\n};\n\n// Define the functions that GPT-4 can call\nconst functions = {\n  generatePhrase: {\n    name: \"generatePhrase\",\n    description: \"Generate a phrase or quote for the game based on category and difficulty\",\n    parameters: {\n      type: \"object\",\n      properties: {\n        phrase: {\n          type: \"string\",\n          description: \"The actual quote or phrase to be guessed\"\n        },\n        source: {\n          type: \"string\",\n          description: \"The origin of the phrase (book title, movie name, etc.)\"\n        },\n        year: {\n          type: \"number\",\n          description: \"The year the source was released/published\"\n        },\n        hint: {\n          type: \"string\",\n          description: \"A subtle hint without giving away the answer\"\n        },\n        additionalInfo: {\n          type: \"object\",\n          properties: {\n            creator: {\n              type: \"string\",\n              description: \"Director (for movies) or Artist/Band (for songs)\"\n            },\n            genre: {\n              type: \"string\",\n              description: \"The genre of the source material\"\n            }\n          }\n        }\n      },\n      required: [\"phrase\", \"source\", \"year\", \"hint\"]\n    }\n  },\n  validateAnswer: {\n    name: \"validateAnswer\",\n    description: \"Validate player's answer against the correct source\",\n    parameters: {\n      type: \"object\",\n      properties: {\n        isCorrect: {\n          type: \"boolean\",\n          description: \"Whether the answer is correct\"\n        },\n        similarity: {\n          type: \"number\",\n          description: \"How close the answer is to the correct one (0-1)\"\n        },\n        feedback: {\n          type: \"string\",\n          description: \"Helpful feedback about why the answer was right or wrong\"\n        }\n      },\n      required: [\"isCorrect\", \"feedback\"]\n    }\n  }\n};\nexport const getPhrase = async function (category) {\n  let difficulty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'MEDIUM';\n  const difficultyConfig = DIFFICULTY_MODIFIERS[difficulty];\n  try {\n    const completion = await openai.chat.completions.create({\n      model: \"gpt-4\",\n      messages: [{\n        role: \"system\",\n        content: \"You are a game master for 'Legendary Lines'. Generate \".concat(difficultyConfig.popularity, \" content for the \").concat(category, \" category. Focus on \").concat(difficultyConfig.description, \".\")\n      }, {\n        role: \"user\",\n        content: \"Generate a \".concat(difficulty.toLowerCase(), \" difficulty \").concat(category.toLowerCase(), \" phrase.\")\n      }],\n      functions: [functions.generatePhrase],\n      function_call: {\n        name: \"generatePhrase\"\n      }\n    });\n    const functionCall = completion.choices[0].message.function_call;\n    return JSON.parse(functionCall.arguments);\n  } catch (error) {\n    console.error('Error generating phrase:', error);\n    throw error;\n  }\n};\nexport const checkAnswer = async function (playerAnswer, correctAnswer) {\n  let answerType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'source';\n  try {\n    const completion = await openai.chat.completions.create({\n      model: \"gpt-4\",\n      messages: [{\n        role: \"system\",\n        content: \"You are validating answers for the Legendary Lines game.\"\n      }, {\n        role: \"user\",\n        content: \"Compare the player's \".concat(answerType, \" answer: \\\"\").concat(playerAnswer, \"\\\" with the correct \").concat(answerType, \": \\\"\").concat(correctAnswer, \"\\\"\")\n      }],\n      functions: [functions.validateAnswer],\n      function_call: {\n        name: \"validateAnswer\"\n      }\n    });\n    const functionCall = completion.choices[0].message.function_call;\n    return JSON.parse(functionCall.arguments);\n  } catch (error) {\n    console.error('Error validating answer:', error);\n    throw error;\n  }\n};\n\n// Debug utilities\nexport const getDebugInfo = () => {\n  if (!DEBUG.enabled) return null;\n  return {\n    retryHistory: retryHistory.attempts,\n    circuitBreakerStatus: {\n      failures: circuitBreaker.failures,\n      isOpen: circuitBreaker.isOpen(),\n      lastFailure: circuitBreaker.lastFailure\n    },\n    currentRetryStrategy: updateRetryStrategy(),\n    errorStats: getErrorStats()\n  };\n};\n\n// Debug mode toggle\nexport const toggleDebugMode = function () {\n  var _options$enabled, _options$verbose, _options$logLevel, _options$retrySimulat;\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (!process.env.NODE_ENV === 'development') {\n    console.warn('Debug mode can only be toggled in development environment');\n    return;\n  }\n  DEBUG.enabled = (_options$enabled = options.enabled) !== null && _options$enabled !== void 0 ? _options$enabled : !DEBUG.enabled;\n  DEBUG.verbose = (_options$verbose = options.verbose) !== null && _options$verbose !== void 0 ? _options$verbose : DEBUG.verbose;\n  DEBUG.logLevel = (_options$logLevel = options.logLevel) !== null && _options$logLevel !== void 0 ? _options$logLevel : DEBUG.logLevel;\n  DEBUG.retrySimulation = (_options$retrySimulat = options.retrySimulation) !== null && _options$retrySimulat !== void 0 ? _options$retrySimulat : DEBUG.retrySimulation;\n  debugLog('info', 'Debug mode settings updated', DEBUG);\n};","map":{"version":3,"names":["OpenAI","DEBUG","enabled","process","env","REACT_APP_DEBUG_MODE","verbose","REACT_APP_DEBUG_VERBOSE","logLevel","REACT_APP_DEBUG_LEVEL","retrySimulation","REACT_APP_SIMULATE_RETRIES","RETRY_PATTERNS","AGGRESSIVE","maxRetries","baseDelay","backoffMultiplier","jitterMax","timeout","CONSERVATIVE","ADAPTIVE","initialMaxRetries","maxRetriesLimit","successThreshold","failureThreshold","adaptiveWindow","retryHistory","attempts","successes","failures","debugLog","level","message","data","arguments","length","undefined","timestamp","Date","toISOString","logLevels","indexOf","console","concat","_objectSpread","debugMode","updateRetryStrategy","recentAttempts","slice","successRate","filter","a","success","Math","max","min","circuitBreaker","lastFailure","threshold","resetTimeout","isOpen","timeSinceLastFailure","now","recordFailure","reset","openai","apiKey","REACT_APP_OPENAI_API_KEY","dangerouslyAllowBrowser","DIFFICULTY_MODIFIERS","EASY","description","popularity","temperature","MEDIUM","HARD","ERROR_TYPES","API_KEY","RATE_LIMIT","NETWORK","VALIDATION","TIMEOUT","SERVER","CONTENT_FILTER","QUOTA_EXCEEDED","UNKNOWN","errorStats","counts","lastOccurrence","retrySuccess","RETRY_CONFIG","timeoutMs","retryableStatuses","sleep","ms","Promise","resolve","setTimeout","getJitter","random","classifyError","error","_error$response","_error$response2","_error$response3","debug","status","response","type","stack","includes","logError","context","errorType","stats","REACT_APP_ERROR_TRACKING_ENABLED","calculateRetryDelay","attempt","exponentialDelay","pow","handleAPIError","retryCount","Error","retryPattern","push","shouldRetry","delay","name","err","getErrorStats","ERROR_TYPES_ENUM","retryWithExponentialBackoff","operation","lastError","_error$response4","_error$response5","log","functions","generatePhrase","parameters","properties","phrase","source","year","hint","additionalInfo","creator","genre","required","validateAnswer","isCorrect","similarity","feedback","getPhrase","category","difficulty","difficultyConfig","completion","chat","completions","create","model","messages","role","content","toLowerCase","function_call","functionCall","choices","JSON","parse","checkAnswer","playerAnswer","correctAnswer","answerType","getDebugInfo","circuitBreakerStatus","currentRetryStrategy","toggleDebugMode","_options$enabled","_options$verbose","_options$logLevel","_options$retrySimulat","options","NODE_ENV","warn"],"sources":["/Users/eimis/test-server/react_projects/cloud-architecture-game/src/services/aiService.js"],"sourcesContent":["import OpenAI from 'openai';\n\n// Debug mode configuration\nconst DEBUG = {\n  enabled: process.env.REACT_APP_DEBUG_MODE === 'true',\n  verbose: process.env.REACT_APP_DEBUG_VERBOSE === 'true',\n  logLevel: process.env.REACT_APP_DEBUG_LEVEL || 'info',\n  retrySimulation: process.env.REACT_APP_SIMULATE_RETRIES === 'true'\n};\n\n// Enhanced retry patterns\nconst RETRY_PATTERNS = {\n  AGGRESSIVE: {\n    maxRetries: 5,\n    baseDelay: 500,\n    backoffMultiplier: 1.2,\n    jitterMax: 100,\n    timeout: 8000\n  },\n  CONSERVATIVE: {\n    maxRetries: 3,\n    baseDelay: 1000,\n    backoffMultiplier: 2,\n    jitterMax: 200,\n    timeout: 15000\n  },\n  ADAPTIVE: {\n    initialMaxRetries: 3,\n    maxRetriesLimit: 7,\n    baseDelay: 800,\n    successThreshold: 0.7,\n    failureThreshold: 0.3,\n    adaptiveWindow: 10 // Number of requests to consider for adaptation\n  }\n};\n\n// Retry history for adaptive pattern\nconst retryHistory = {\n  attempts: [],\n  successes: 0,\n  failures: 0\n};\n\nconst debugLog = (level, message, data = {}) => {\n  if (!DEBUG.enabled) return;\n  \n  const timestamp = new Date().toISOString();\n  const logLevels = ['error', 'warn', 'info', 'debug'];\n  \n  if (logLevels.indexOf(level) <= logLevels.indexOf(DEBUG.logLevel)) {\n    console[level](`[${timestamp}] ${message}`, {\n      ...data,\n      debugMode: true,\n      logLevel: level\n    });\n  }\n};\n\n// Adaptive retry strategy\nconst updateRetryStrategy = () => {\n  if (retryHistory.attempts.length < RETRY_PATTERNS.ADAPTIVE.adaptiveWindow) {\n    return RETRY_PATTERNS.CONSERVATIVE;\n  }\n\n  const recentAttempts = retryHistory.attempts.slice(-RETRY_PATTERNS.ADAPTIVE.adaptiveWindow);\n  const successRate = recentAttempts.filter(a => a.success).length / recentAttempts.length;\n\n  debugLog('info', 'Updating retry strategy', { successRate, recentAttempts });\n\n  if (successRate > RETRY_PATTERNS.ADAPTIVE.successThreshold) {\n    return {\n      ...RETRY_PATTERNS.CONSERVATIVE,\n      maxRetries: Math.max(2, RETRY_PATTERNS.CONSERVATIVE.maxRetries - 1)\n    };\n  } else if (successRate < RETRY_PATTERNS.ADAPTIVE.failureThreshold) {\n    return {\n      ...RETRY_PATTERNS.AGGRESSIVE,\n      maxRetries: Math.min(RETRY_PATTERNS.ADAPTIVE.maxRetriesLimit, \n                          RETRY_PATTERNS.AGGRESSIVE.maxRetries + 1)\n    };\n  }\n\n  return RETRY_PATTERNS.CONSERVATIVE;\n};\n\n// Circuit breaker implementation\nconst circuitBreaker = {\n  failures: 0,\n  lastFailure: null,\n  threshold: 5,\n  resetTimeout: 30000,\n  \n  isOpen() {\n    if (!this.lastFailure) return false;\n    const timeSinceLastFailure = Date.now() - this.lastFailure;\n    return this.failures >= this.threshold && timeSinceLastFailure < this.resetTimeout;\n  },\n  \n  recordFailure() {\n    this.failures++;\n    this.lastFailure = Date.now();\n    debugLog('warn', 'Circuit breaker failure recorded', { \n      failures: this.failures,\n      threshold: this.threshold \n    });\n  },\n  \n  reset() {\n    this.failures = 0;\n    this.lastFailure = null;\n    debugLog('info', 'Circuit breaker reset');\n  }\n};\n\nconst openai = new OpenAI({\n  apiKey: process.env.REACT_APP_OPENAI_API_KEY,\n  dangerouslyAllowBrowser: true\n});\n\nconst DIFFICULTY_MODIFIERS = {\n  EASY: {\n    description: \"well-known and popular quotes from the last 30 years\",\n    popularity: \"highly popular\",\n    maxRetries: 3,\n    temperature: 0.5\n  },\n  MEDIUM: {\n    description: \"moderately known quotes from the last 50 years\",\n    popularity: \"moderately known\",\n    maxRetries: 3,\n    temperature: 0.7\n  },\n  HARD: {\n    description: \"obscure or historical quotes from any time period\",\n    popularity: \"less known\",\n    maxRetries: 3,\n    temperature: 0.9\n  }\n};\n\n// Enhanced error types\nconst ERROR_TYPES = {\n  API_KEY: 'API_KEY_ERROR',\n  RATE_LIMIT: 'RATE_LIMIT_ERROR',\n  NETWORK: 'NETWORK_ERROR',\n  VALIDATION: 'VALIDATION_ERROR',\n  TIMEOUT: 'TIMEOUT_ERROR',\n  SERVER: 'SERVER_ERROR',\n  CONTENT_FILTER: 'CONTENT_FILTER_ERROR',\n  QUOTA_EXCEEDED: 'QUOTA_EXCEEDED_ERROR',\n  UNKNOWN: 'UNKNOWN_ERROR'\n};\n\n// Error tracking analytics\nconst errorStats = {\n  counts: {},\n  lastOccurrence: {},\n  retrySuccess: {},\n};\n\n// Sophisticated retry configuration\nconst RETRY_CONFIG = {\n  baseDelay: 1000,\n  maxRetries: 3,\n  timeoutMs: 10000,\n  backoffMultiplier: 1.5,\n  jitterMax: 200,\n  retryableStatuses: [429, 503, 502, 500],\n};\n\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n// Add jitter to avoid thundering herd problem\nconst getJitter = () => Math.random() * RETRY_CONFIG.jitterMax;\n\n// Enhanced error classification\nconst classifyError = (error) => {\n  // Log error for debugging\n  console.debug('Error details:', {\n    message: error.message,\n    status: error.response?.status,\n    type: error.type,\n    stack: error.stack,\n  });\n\n  if (error.message.includes('API key')) return ERROR_TYPES.API_KEY;\n  if (error.response?.status === 429) return ERROR_TYPES.RATE_LIMIT;\n  if (error.message.includes('network')) return ERROR_TYPES.NETWORK;\n  if (error.message.includes('timeout')) return ERROR_TYPES.TIMEOUT;\n  if (error.response?.status >= 500) return ERROR_TYPES.SERVER;\n  if (error.message.includes('content filter')) return ERROR_TYPES.CONTENT_FILTER;\n  if (error.message.includes('quota')) return ERROR_TYPES.QUOTA_EXCEEDED;\n  if (error.message.includes('Invalid API response')) return ERROR_TYPES.VALIDATION;\n  return ERROR_TYPES.UNKNOWN;\n};\n\n// Error logging with timestamp and context\nconst logError = (error, context = {}) => {\n  const errorType = classifyError(error);\n  const timestamp = new Date().toISOString();\n  \n  // Update error statistics\n  errorStats.counts[errorType] = (errorStats.counts[errorType] || 0) + 1;\n  errorStats.lastOccurrence[errorType] = timestamp;\n\n  // Log to console with structured format\n  console.error('Game Error:', {\n    type: errorType,\n    timestamp,\n    message: error.message,\n    context,\n    stats: errorStats.counts[errorType],\n    stack: error.stack,\n  });\n\n  // Could be extended to send to external error tracking service\n  if (process.env.REACT_APP_ERROR_TRACKING_ENABLED === 'true') {\n    // Example: sendToErrorTracking(error, context);\n  }\n};\n\n// Sophisticated retry strategy with exponential backoff and jitter\nconst calculateRetryDelay = (attempt) => {\n  const exponentialDelay = RETRY_CONFIG.baseDelay * Math.pow(RETRY_CONFIG.backoffMultiplier, attempt);\n  return exponentialDelay + getJitter();\n};\n\n// Enhanced error handling with retry strategy\nexport const handleAPIError = async (error, retryCount = 0, context = {}) => {\n  if (DEBUG.enabled) {\n    debugLog('error', 'API Error occurred', { error, retryCount, context });\n  }\n\n  // Check circuit breaker\n  if (circuitBreaker.isOpen()) {\n    throw new Error('Service temporarily unavailable. Please try again later.');\n  }\n\n  const errorType = classifyError(error);\n  const retryPattern = updateRetryStrategy();\n\n  if (DEBUG.retrySimulation) {\n    debugLog('info', 'Simulating retry scenario', { errorType, retryPattern });\n  }\n\n  try {\n    // ... existing error handling logic ...\n\n    // Record success in retry history\n    retryHistory.attempts.push({ success: true, timestamp: Date.now() });\n    circuitBreaker.reset();\n\n    return {\n      shouldRetry: true,\n      delay: calculateRetryDelay(retryCount, retryPattern),\n      errorType,\n      retryCount: retryCount + 1,\n      retryPattern: retryPattern.name\n    };\n  } catch (err) {\n    // Record failure in retry history\n    retryHistory.attempts.push({ success: false, timestamp: Date.now() });\n    circuitBreaker.recordFailure();\n\n    if (DEBUG.enabled) {\n      debugLog('error', 'Retry attempt failed', { \n        attempt: retryCount + 1,\n        maxRetries: retryPattern.maxRetries,\n        error: err\n      });\n    }\n\n    throw err;\n  }\n};\n\n// Export error statistics for monitoring\nexport const getErrorStats = () => ({\n  ...errorStats,\n  timestamp: new Date().toISOString(),\n});\n\n// Export error types for external use\nexport const ERROR_TYPES_ENUM = ERROR_TYPES;\n\nconst retryWithExponentialBackoff = async (operation, maxRetries = 3, baseDelay = 1000) => {\n  let lastError;\n  \n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error;\n      \n      if (error.response?.status === 429 || error.response?.status === 503) {\n        const delay = baseDelay * Math.pow(2, attempt);\n        console.log(`Attempt ${attempt + 1} failed, retrying in ${delay}ms...`);\n        await sleep(delay);\n        continue;\n      }\n      \n      throw error;\n    }\n  }\n  \n  throw lastError;\n};\n\n// Define the functions that GPT-4 can call\nconst functions = {\n  generatePhrase: {\n    name: \"generatePhrase\",\n    description: \"Generate a phrase or quote for the game based on category and difficulty\",\n    parameters: {\n      type: \"object\",\n      properties: {\n        phrase: {\n          type: \"string\",\n          description: \"The actual quote or phrase to be guessed\"\n        },\n        source: {\n          type: \"string\",\n          description: \"The origin of the phrase (book title, movie name, etc.)\"\n        },\n        year: {\n          type: \"number\",\n          description: \"The year the source was released/published\"\n        },\n        hint: {\n          type: \"string\",\n          description: \"A subtle hint without giving away the answer\"\n        },\n        additionalInfo: {\n          type: \"object\",\n          properties: {\n            creator: {\n              type: \"string\",\n              description: \"Director (for movies) or Artist/Band (for songs)\"\n            },\n            genre: {\n              type: \"string\",\n              description: \"The genre of the source material\"\n            }\n          }\n        }\n      },\n      required: [\"phrase\", \"source\", \"year\", \"hint\"]\n    }\n  },\n  validateAnswer: {\n    name: \"validateAnswer\",\n    description: \"Validate player's answer against the correct source\",\n    parameters: {\n      type: \"object\",\n      properties: {\n        isCorrect: {\n          type: \"boolean\",\n          description: \"Whether the answer is correct\"\n        },\n        similarity: {\n          type: \"number\",\n          description: \"How close the answer is to the correct one (0-1)\"\n        },\n        feedback: {\n          type: \"string\",\n          description: \"Helpful feedback about why the answer was right or wrong\"\n        }\n      },\n      required: [\"isCorrect\", \"feedback\"]\n    }\n  }\n};\n\nexport const getPhrase = async (category, difficulty = 'MEDIUM') => {\n  const difficultyConfig = DIFFICULTY_MODIFIERS[difficulty];\n  \n  try {\n    const completion = await openai.chat.completions.create({\n      model: \"gpt-4\",\n      messages: [\n        {\n          role: \"system\",\n          content: `You are a game master for 'Legendary Lines'. Generate ${difficultyConfig.popularity} content for the ${category} category. Focus on ${difficultyConfig.description}.`\n        },\n        {\n          role: \"user\",\n          content: `Generate a ${difficulty.toLowerCase()} difficulty ${category.toLowerCase()} phrase.`\n        }\n      ],\n      functions: [functions.generatePhrase],\n      function_call: { name: \"generatePhrase\" }\n    });\n\n    const functionCall = completion.choices[0].message.function_call;\n    return JSON.parse(functionCall.arguments);\n  } catch (error) {\n    console.error('Error generating phrase:', error);\n    throw error;\n  }\n};\n\nexport const checkAnswer = async (playerAnswer, correctAnswer, answerType = 'source') => {\n  try {\n    const completion = await openai.chat.completions.create({\n      model: \"gpt-4\",\n      messages: [\n        {\n          role: \"system\",\n          content: \"You are validating answers for the Legendary Lines game.\"\n        },\n        {\n          role: \"user\",\n          content: `Compare the player's ${answerType} answer: \"${playerAnswer}\" with the correct ${answerType}: \"${correctAnswer}\"`\n        }\n      ],\n      functions: [functions.validateAnswer],\n      function_call: { name: \"validateAnswer\" }\n    });\n\n    const functionCall = completion.choices[0].message.function_call;\n    return JSON.parse(functionCall.arguments);\n  } catch (error) {\n    console.error('Error validating answer:', error);\n    throw error;\n  }\n};\n\n// Debug utilities\nexport const getDebugInfo = () => {\n  if (!DEBUG.enabled) return null;\n  \n  return {\n    retryHistory: retryHistory.attempts,\n    circuitBreakerStatus: {\n      failures: circuitBreaker.failures,\n      isOpen: circuitBreaker.isOpen(),\n      lastFailure: circuitBreaker.lastFailure\n    },\n    currentRetryStrategy: updateRetryStrategy(),\n    errorStats: getErrorStats()\n  };\n};\n\n// Debug mode toggle\nexport const toggleDebugMode = (options = {}) => {\n  if (!process.env.NODE_ENV === 'development') {\n    console.warn('Debug mode can only be toggled in development environment');\n    return;\n  }\n\n  DEBUG.enabled = options.enabled ?? !DEBUG.enabled;\n  DEBUG.verbose = options.verbose ?? DEBUG.verbose;\n  DEBUG.logLevel = options.logLevel ?? DEBUG.logLevel;\n  DEBUG.retrySimulation = options.retrySimulation ?? DEBUG.retrySimulation;\n\n  debugLog('info', 'Debug mode settings updated', DEBUG);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}