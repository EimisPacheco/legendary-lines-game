{"ast":null,"code":"import OpenAI from 'openai';\nconst openai = new OpenAI({\n  apiKey: process.env.REACT_APP_OPENAI_API_KEY,\n  dangerouslyAllowBrowser: true // Added for development\n});\nconst DIFFICULTY_MODIFIERS = {\n  EASY: {\n    popularity: \"well-known\",\n    description: \"commonly recognized phrases\",\n    temperature: 0.7\n  },\n  MEDIUM: {\n    popularity: \"moderately known\",\n    description: \"somewhat challenging phrases\",\n    temperature: 0.8\n  },\n  HARD: {\n    popularity: \"obscure\",\n    description: \"rare and challenging phrases\",\n    temperature: 0.9\n  }\n};\nexport const getPhrase = async function () {\n  let category = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'QUOTE';\n  let difficulty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'MEDIUM';\n  let conversationHistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  // Add default category if none is selected\n  if (!category) {\n    console.warn('No category provided, using default: QUOTE');\n    category = 'QUOTE';\n  }\n  const difficultyConfig = DIFFICULTY_MODIFIERS[difficulty];\n  try {\n    const systemMessage = {\n      role: \"system\",\n      content: \"You are a game master for 'Legendary Lines'. Generate \".concat(difficultyConfig.popularity, \" content for the \").concat(category, \" category. Focus on \").concat(difficultyConfig.description, \".\")\n    };\n    const userMessage = {\n      role: \"user\",\n      content: \"Generate a \".concat(difficulty.toLowerCase(), \" difficulty \").concat(category.toLowerCase(), \" phrase.\")\n    };\n\n    // Add conversation history context if available\n    const messages = [systemMessage];\n    if (conversationHistory) {\n      messages.push({\n        role: \"system\",\n        content: \"Previous game history: \".concat(JSON.stringify(conversationHistory))\n      });\n    }\n    messages.push(userMessage);\n    const completion = await openai.chat.completions.create({\n      model: \"gpt-4o\",\n      messages: messages,\n      functions: [{\n        name: \"generatePhrase\",\n        description: \"Generate a phrase or quote for the game based on category and difficulty\",\n        parameters: {\n          type: \"object\",\n          properties: {\n            phrase: {\n              type: \"string\",\n              description: \"The actual quote or phrase to be guessed\"\n            },\n            source: {\n              type: \"string\",\n              description: \"The origin of the phrase (book title, movie name, etc.)\"\n            },\n            year: {\n              type: \"number\",\n              description: \"The year the source was released/published\"\n            },\n            hint: {\n              type: \"string\",\n              description: \"A subtle hint without giving away the answer\"\n            },\n            additionalInfo: {\n              type: \"object\",\n              properties: {\n                creator: {\n                  type: \"string\",\n                  description: \"Director (for movies), Artist/Band (for songs), or Author (for books)\"\n                },\n                genre: {\n                  type: \"string\",\n                  description: \"The genre of the source material\"\n                }\n              }\n            }\n          },\n          required: [\"phrase\", \"source\", \"year\", \"hint\"]\n        }\n      }],\n      function_call: {\n        name: \"generatePhrase\"\n      }\n    });\n    const functionCall = completion.choices[0].message.function_call;\n    return JSON.parse(functionCall.arguments);\n  } catch (error) {\n    console.error('Error generating phrase:', error);\n    throw error;\n  }\n};\nexport const checkAnswer = async function (playerAnswer, correctAnswer) {\n  let answerType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'source';\n  let conversationHistory = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  try {\n    const messages = [{\n      role: \"system\",\n      content: \"You are validating answers for the Legendary Lines game. \\n                 For bonus round questions (about guessing year/creator):\\n                 1. First validate if the player wants to attempt the bonus (yes/no/sure vs. no/pass/skip)\\n                 2. Only if they agree, then validate their actual guess\\n                 3. If they decline, acknowledge their choice to keep current points\\n                 Previous conversation context: \".concat(JSON.stringify(conversationHistory))\n    }, {\n      role: \"user\",\n      content: \"Question type: \".concat(answerType, \"\\n                 Player's answer: \\\"\").concat(playerAnswer, \"\\\"\\n                 Correct answer: \\\"\").concat(correctAnswer, \"\\\"\\n                 Context: \").concat(answerType.includes('bonus_confirmation') ? \"This is a response to whether they want to attempt the bonus round\" : \"This is an actual answer attempt\")\n    }];\n    const completion = await openai.chat.completions.create({\n      model: \"gpt-4o\",\n      messages: messages,\n      functions: [{\n        name: \"validateAnswer\",\n        description: \"Validate player's answer against the correct source or their intent for bonus questions\",\n        parameters: {\n          type: \"object\",\n          properties: {\n            isCorrect: {\n              type: \"boolean\",\n              description: \"Whether the answer is correct or if the player wants to continue with bonus\"\n            },\n            similarity: {\n              type: \"number\",\n              description: \"How close the answer is to the correct one (0-1)\"\n            },\n            feedback: {\n              type: \"string\",\n              description: \"Helpful feedback about why the answer was right or wrong\"\n            },\n            isBonusResponse: {\n              type: \"boolean\",\n              description: \"Whether this was a response to a bonus question prompt\"\n            },\n            bonusDeclined: {\n              type: \"boolean\",\n              description: \"Whether the player has declined to attempt the bonus round\"\n            }\n          },\n          required: [\"isCorrect\", \"feedback\", \"isBonusResponse\"]\n        }\n      }],\n      function_call: {\n        name: \"validateAnswer\"\n      }\n    });\n    const functionCall = completion.choices[0].message.function_call;\n    return JSON.parse(functionCall.arguments);\n  } catch (error) {\n    console.error('Error validating answer:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["OpenAI","openai","apiKey","process","env","REACT_APP_OPENAI_API_KEY","dangerouslyAllowBrowser","DIFFICULTY_MODIFIERS","EASY","popularity","description","temperature","MEDIUM","HARD","getPhrase","category","arguments","length","undefined","difficulty","conversationHistory","console","warn","difficultyConfig","systemMessage","role","content","concat","userMessage","toLowerCase","messages","push","JSON","stringify","completion","chat","completions","create","model","functions","name","parameters","type","properties","phrase","source","year","hint","additionalInfo","creator","genre","required","function_call","functionCall","choices","message","parse","error","checkAnswer","playerAnswer","correctAnswer","answerType","includes","isCorrect","similarity","feedback","isBonusResponse","bonusDeclined"],"sources":["/Users/eimis/test-server/react_projects/legendary-lines-game/src/services/aiService.js"],"sourcesContent":["import OpenAI from 'openai';\n\nconst openai = new OpenAI({\n  apiKey: process.env.REACT_APP_OPENAI_API_KEY,\n  dangerouslyAllowBrowser: true  // Added for development\n});\n\nconst DIFFICULTY_MODIFIERS = {\n  EASY: {\n    popularity: \"well-known\",\n    description: \"commonly recognized phrases\",\n    temperature: 0.7\n  },\n  MEDIUM: {\n    popularity: \"moderately known\",\n    description: \"somewhat challenging phrases\",\n    temperature: 0.8\n  },\n  HARD: {\n    popularity: \"obscure\",\n    description: \"rare and challenging phrases\",\n    temperature: 0.9\n  }\n};\n\nexport const getPhrase = async (category = 'QUOTE', difficulty = 'MEDIUM', conversationHistory = null) => {\n  // Add default category if none is selected\n  if (!category) {\n    console.warn('No category provided, using default: QUOTE');\n    category = 'QUOTE';\n  }\n\n  const difficultyConfig = DIFFICULTY_MODIFIERS[difficulty];\n  \n  try {\n    const systemMessage = {\n      role: \"system\",\n      content: `You are a game master for 'Legendary Lines'. Generate ${difficultyConfig.popularity} content for the ${category} category. Focus on ${difficultyConfig.description}.`\n    };\n\n    const userMessage = {\n      role: \"user\",\n      content: `Generate a ${difficulty.toLowerCase()} difficulty ${category.toLowerCase()} phrase.`\n    };\n\n    // Add conversation history context if available\n    const messages = [systemMessage];\n    if (conversationHistory) {\n      messages.push({\n        role: \"system\",\n        content: `Previous game history: ${JSON.stringify(conversationHistory)}`\n      });\n    }\n    messages.push(userMessage);\n\n    const completion = await openai.chat.completions.create({\n      model: \"gpt-4o\",\n      messages: messages,\n      functions: [{\n        name: \"generatePhrase\",\n        description: \"Generate a phrase or quote for the game based on category and difficulty\",\n        parameters: {\n          type: \"object\",\n          properties: {\n            phrase: {\n              type: \"string\",\n              description: \"The actual quote or phrase to be guessed\"\n            },\n            source: {\n              type: \"string\",\n              description: \"The origin of the phrase (book title, movie name, etc.)\"\n            },\n            year: {\n              type: \"number\",\n              description: \"The year the source was released/published\"\n            },\n            hint: {\n              type: \"string\",\n              description: \"A subtle hint without giving away the answer\"\n            },\n            additionalInfo: {\n              type: \"object\",\n              properties: {\n                creator: {\n                  type: \"string\",\n                  description: \"Director (for movies), Artist/Band (for songs), or Author (for books)\"\n                },\n                genre: {\n                  type: \"string\",\n                  description: \"The genre of the source material\"\n                }\n              }\n            }\n          },\n          required: [\"phrase\", \"source\", \"year\", \"hint\"]\n        }\n      }],\n      function_call: { name: \"generatePhrase\" }\n    });\n\n    const functionCall = completion.choices[0].message.function_call;\n    return JSON.parse(functionCall.arguments);\n  } catch (error) {\n    console.error('Error generating phrase:', error);\n    throw error;\n  }\n};\n\nexport const checkAnswer = async (playerAnswer, correctAnswer, answerType = 'source', conversationHistory = []) => {\n  try {\n    const messages = [\n      {\n        role: \"system\",\n        content: `You are validating answers for the Legendary Lines game. \n                 For bonus round questions (about guessing year/creator):\n                 1. First validate if the player wants to attempt the bonus (yes/no/sure vs. no/pass/skip)\n                 2. Only if they agree, then validate their actual guess\n                 3. If they decline, acknowledge their choice to keep current points\n                 Previous conversation context: ${JSON.stringify(conversationHistory)}`\n      },\n      {\n        role: \"user\",\n        content: `Question type: ${answerType}\n                 Player's answer: \"${playerAnswer}\"\n                 Correct answer: \"${correctAnswer}\"\n                 Context: ${\n                   answerType.includes('bonus_confirmation') \n                   ? \"This is a response to whether they want to attempt the bonus round\" \n                   : \"This is an actual answer attempt\"\n                 }`\n      }\n    ];\n\n    const completion = await openai.chat.completions.create({\n      model: \"gpt-4o\",\n      messages: messages,\n      functions: [{\n        name: \"validateAnswer\",\n        description: \"Validate player's answer against the correct source or their intent for bonus questions\",\n        parameters: {\n          type: \"object\",\n          properties: {\n            isCorrect: {\n              type: \"boolean\",\n              description: \"Whether the answer is correct or if the player wants to continue with bonus\"\n            },\n            similarity: {\n              type: \"number\",\n              description: \"How close the answer is to the correct one (0-1)\"\n            },\n            feedback: {\n              type: \"string\",\n              description: \"Helpful feedback about why the answer was right or wrong\"\n            },\n            isBonusResponse: {\n              type: \"boolean\",\n              description: \"Whether this was a response to a bonus question prompt\"\n            },\n            bonusDeclined: {\n              type: \"boolean\",\n              description: \"Whether the player has declined to attempt the bonus round\"\n            }\n          },\n          required: [\"isCorrect\", \"feedback\", \"isBonusResponse\"]\n        }\n      }],\n      function_call: { name: \"validateAnswer\" }\n    });\n\n    const functionCall = completion.choices[0].message.function_call;\n    return JSON.parse(functionCall.arguments);\n  } catch (error) {\n    console.error('Error validating answer:', error);\n    throw error;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}