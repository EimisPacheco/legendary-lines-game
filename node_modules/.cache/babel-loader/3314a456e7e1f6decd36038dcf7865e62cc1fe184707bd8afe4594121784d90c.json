{"ast":null,"code":"import _objectSpread from \"/Users/eimis/test-server/react_projects/cloud-architecture-game/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport OpenAI from 'openai';\n\n// Debug mode configuration\nconst DEBUG = {\n  enabled: process.env.REACT_APP_DEBUG_MODE === 'true',\n  verbose: process.env.REACT_APP_DEBUG_VERBOSE === 'true',\n  logLevel: process.env.REACT_APP_DEBUG_LEVEL || 'info',\n  retrySimulation: process.env.REACT_APP_SIMULATE_RETRIES === 'true'\n};\n\n// Enhanced retry patterns\nconst RETRY_PATTERNS = {\n  AGGRESSIVE: {\n    maxRetries: 5,\n    baseDelay: 500,\n    backoffMultiplier: 1.2,\n    jitterMax: 100,\n    timeout: 8000\n  },\n  CONSERVATIVE: {\n    maxRetries: 3,\n    baseDelay: 1000,\n    backoffMultiplier: 2,\n    jitterMax: 200,\n    timeout: 15000\n  },\n  ADAPTIVE: {\n    initialMaxRetries: 3,\n    maxRetriesLimit: 7,\n    baseDelay: 800,\n    successThreshold: 0.7,\n    failureThreshold: 0.3,\n    adaptiveWindow: 10 // Number of requests to consider for adaptation\n  }\n};\n\n// Retry history for adaptive pattern\nconst retryHistory = {\n  attempts: [],\n  successes: 0,\n  failures: 0\n};\nconst debugLog = function (level, message) {\n  let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (!DEBUG.enabled) return;\n  const timestamp = new Date().toISOString();\n  const logLevels = ['error', 'warn', 'info', 'debug'];\n  if (logLevels.indexOf(level) <= logLevels.indexOf(DEBUG.logLevel)) {\n    console[level](\"[\".concat(timestamp, \"] \").concat(message), _objectSpread(_objectSpread({}, data), {}, {\n      debugMode: true,\n      logLevel: level\n    }));\n  }\n};\n\n// Adaptive retry strategy\nconst updateRetryStrategy = () => {\n  if (retryHistory.attempts.length < RETRY_PATTERNS.ADAPTIVE.adaptiveWindow) {\n    return RETRY_PATTERNS.CONSERVATIVE;\n  }\n  const recentAttempts = retryHistory.attempts.slice(-RETRY_PATTERNS.ADAPTIVE.adaptiveWindow);\n  const successRate = recentAttempts.filter(a => a.success).length / recentAttempts.length;\n  debugLog('info', 'Updating retry strategy', {\n    successRate,\n    recentAttempts\n  });\n  if (successRate > RETRY_PATTERNS.ADAPTIVE.successThreshold) {\n    return _objectSpread(_objectSpread({}, RETRY_PATTERNS.CONSERVATIVE), {}, {\n      maxRetries: Math.max(2, RETRY_PATTERNS.CONSERVATIVE.maxRetries - 1)\n    });\n  } else if (successRate < RETRY_PATTERNS.ADAPTIVE.failureThreshold) {\n    return _objectSpread(_objectSpread({}, RETRY_PATTERNS.AGGRESSIVE), {}, {\n      maxRetries: Math.min(RETRY_PATTERNS.ADAPTIVE.maxRetriesLimit, RETRY_PATTERNS.AGGRESSIVE.maxRetries + 1)\n    });\n  }\n  return RETRY_PATTERNS.CONSERVATIVE;\n};\n\n// Circuit breaker implementation\nconst circuitBreaker = {\n  failures: 0,\n  lastFailure: null,\n  threshold: 5,\n  resetTimeout: 30000,\n  isOpen() {\n    if (!this.lastFailure) return false;\n    const timeSinceLastFailure = Date.now() - this.lastFailure;\n    return this.failures >= this.threshold && timeSinceLastFailure < this.resetTimeout;\n  },\n  recordFailure() {\n    this.failures++;\n    this.lastFailure = Date.now();\n    debugLog('warn', 'Circuit breaker failure recorded', {\n      failures: this.failures,\n      threshold: this.threshold\n    });\n  },\n  reset() {\n    this.failures = 0;\n    this.lastFailure = null;\n    debugLog('info', 'Circuit breaker reset');\n  }\n};\nconst openai = new OpenAI({\n  apiKey: process.env.REACT_APP_OPENAI_API_KEY\n});\nconst DIFFICULTY_MODIFIERS = {\n  EASY: {\n    description: \"well-known and popular quotes from the last 30 years\",\n    popularity: \"highly popular\",\n    maxRetries: 3,\n    temperature: 0.5\n  },\n  MEDIUM: {\n    description: \"moderately known quotes from the last 50 years\",\n    popularity: \"moderately known\",\n    maxRetries: 3,\n    temperature: 0.7\n  },\n  HARD: {\n    description: \"obscure or historical quotes from any time period\",\n    popularity: \"less known\",\n    maxRetries: 3,\n    temperature: 0.9\n  }\n};\n\n// Enhanced error types\nconst ERROR_TYPES = {\n  API_KEY: 'API_KEY_ERROR',\n  RATE_LIMIT: 'RATE_LIMIT_ERROR',\n  NETWORK: 'NETWORK_ERROR',\n  VALIDATION: 'VALIDATION_ERROR',\n  TIMEOUT: 'TIMEOUT_ERROR',\n  SERVER: 'SERVER_ERROR',\n  CONTENT_FILTER: 'CONTENT_FILTER_ERROR',\n  QUOTA_EXCEEDED: 'QUOTA_EXCEEDED_ERROR',\n  UNKNOWN: 'UNKNOWN_ERROR'\n};\n\n// Error tracking analytics\nconst errorStats = {\n  counts: {},\n  lastOccurrence: {},\n  retrySuccess: {}\n};\n\n// Sophisticated retry configuration\nconst RETRY_CONFIG = {\n  baseDelay: 1000,\n  maxRetries: 3,\n  timeoutMs: 10000,\n  backoffMultiplier: 1.5,\n  jitterMax: 200,\n  retryableStatuses: [429, 503, 502, 500]\n};\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// Add jitter to avoid thundering herd problem\nconst getJitter = () => Math.random() * RETRY_CONFIG.jitterMax;\n\n// Enhanced error classification\nconst classifyError = error => {\n  var _error$response, _error$response2, _error$response3;\n  // Log error for debugging\n  console.debug('Error details:', {\n    message: error.message,\n    status: (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status,\n    type: error.type,\n    stack: error.stack\n  });\n  if (error.message.includes('API key')) return ERROR_TYPES.API_KEY;\n  if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 429) return ERROR_TYPES.RATE_LIMIT;\n  if (error.message.includes('network')) return ERROR_TYPES.NETWORK;\n  if (error.message.includes('timeout')) return ERROR_TYPES.TIMEOUT;\n  if (((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status) >= 500) return ERROR_TYPES.SERVER;\n  if (error.message.includes('content filter')) return ERROR_TYPES.CONTENT_FILTER;\n  if (error.message.includes('quota')) return ERROR_TYPES.QUOTA_EXCEEDED;\n  if (error.message.includes('Invalid API response')) return ERROR_TYPES.VALIDATION;\n  return ERROR_TYPES.UNKNOWN;\n};\n\n// Error logging with timestamp and context\nconst logError = function (error) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const errorType = classifyError(error);\n  const timestamp = new Date().toISOString();\n\n  // Update error statistics\n  errorStats.counts[errorType] = (errorStats.counts[errorType] || 0) + 1;\n  errorStats.lastOccurrence[errorType] = timestamp;\n\n  // Log to console with structured format\n  console.error('Game Error:', {\n    type: errorType,\n    timestamp,\n    message: error.message,\n    context,\n    stats: errorStats.counts[errorType],\n    stack: error.stack\n  });\n\n  // Could be extended to send to external error tracking service\n  if (process.env.REACT_APP_ERROR_TRACKING_ENABLED === 'true') {\n    // Example: sendToErrorTracking(error, context);\n  }\n};\n\n// Sophisticated retry strategy with exponential backoff and jitter\nconst calculateRetryDelay = attempt => {\n  const exponentialDelay = RETRY_CONFIG.baseDelay * Math.pow(RETRY_CONFIG.backoffMultiplier, attempt);\n  return exponentialDelay + getJitter();\n};\n\n// Enhanced error handling with retry strategy\nexport const handleAPIError = async function (error) {\n  let retryCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (DEBUG.enabled) {\n    debugLog('error', 'API Error occurred', {\n      error,\n      retryCount,\n      context\n    });\n  }\n\n  // Check circuit breaker\n  if (circuitBreaker.isOpen()) {\n    throw new Error('Service temporarily unavailable. Please try again later.');\n  }\n  const errorType = classifyError(error);\n  const retryPattern = updateRetryStrategy();\n  if (DEBUG.retrySimulation) {\n    debugLog('info', 'Simulating retry scenario', {\n      errorType,\n      retryPattern\n    });\n  }\n  try {\n    // ... existing error handling logic ...\n\n    // Record success in retry history\n    retryHistory.attempts.push({\n      success: true,\n      timestamp: Date.now()\n    });\n    circuitBreaker.reset();\n    return {\n      shouldRetry: true,\n      delay: calculateRetryDelay(retryCount, retryPattern),\n      errorType,\n      retryCount: retryCount + 1,\n      retryPattern: retryPattern.name\n    };\n  } catch (err) {\n    // Record failure in retry history\n    retryHistory.attempts.push({\n      success: false,\n      timestamp: Date.now()\n    });\n    circuitBreaker.recordFailure();\n    if (DEBUG.enabled) {\n      debugLog('error', 'Retry attempt failed', {\n        attempt: retryCount + 1,\n        maxRetries: retryPattern.maxRetries,\n        error: err\n      });\n    }\n    throw err;\n  }\n};\n\n// Export error statistics for monitoring\nexport const getErrorStats = () => _objectSpread(_objectSpread({}, errorStats), {}, {\n  timestamp: new Date().toISOString()\n});\n\n// Export error types for external use\nexport const ERROR_TYPES_ENUM = ERROR_TYPES;\nexport const getPhrase = async function (category) {\n  let difficulty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'MEDIUM';\n  const difficultyConfig = DIFFICULTY_MODIFIERS[difficulty];\n  const operation = async () => {\n    try {\n      const systemPrompt = \"You are a game master for 'Legendary Lines'. \\n        Generate \".concat(difficultyConfig.popularity, \" content for the \").concat(category, \" category.\\n        Focus on \").concat(difficultyConfig.description, \".\");\n      const prompt = \"Generate a \".concat(difficulty.toLowerCase(), \" difficulty \").concat(category.toLowerCase(), \" quote or phrase.\\n        The response must be in this exact JSON format:\\n        {\\n          \\\"phrase\\\": \\\"the actual quote or phrase\\\",\\n          \\\"source\\\": \\\"where it's from\\\",\\n          \\\"year\\\": YYYY,\\n          \\\"hint\\\": \\\"a subtle hint without giving away the answer\\\",\\n          \\\"difficulty\\\": \\\"\").concat(difficulty, \"\\\",\\n          \\\"category\\\": \\\"\").concat(category, \"\\\"\\n        }\");\n      const completion = await openai.chat.completions.create({\n        messages: [{\n          role: \"system\",\n          content: systemPrompt\n        }, {\n          role: \"user\",\n          content: prompt\n        }],\n        model: \"gpt-4\",\n        temperature: difficultyConfig.temperature\n      });\n      const response = JSON.parse(completion.choices[0].message.content);\n\n      // Validate response format\n      const requiredFields = ['phrase', 'source', 'year', 'hint', 'difficulty', 'category'];\n      for (const field of requiredFields) {\n        if (!response[field]) {\n          throw new Error(\"Invalid API response: missing \".concat(field));\n        }\n      }\n      return response;\n    } catch (error) {\n      if (error.message.includes('Invalid API response')) {\n        throw new Error('Failed to generate valid phrase. Please try again.');\n      }\n      throw error;\n    }\n  };\n  return retryWithExponentialBackoff(operation, difficultyConfig.maxRetries);\n};\nexport const checkAnswer = async (userAnswer, correctAnswer, category) => {\n  const operation = async () => {\n    try {\n      const systemPrompt = \"You are an answer validator for the 'Legendary Lines' game.\";\n      const prompt = \"Compare these answers for a \".concat(category, \" quote:\\n        User's answer: \\\"\").concat(userAnswer, \"\\\"\\n        Correct answer: \\\"\").concat(correctAnswer.source, \"\\\"\\n        Difficulty level: \").concat(correctAnswer.difficulty, \"\\n        \\n        Consider variations in naming and common abbreviations.\\n        For harder difficulty levels, be more lenient with partial matches.\\n        Return a JSON response in this format:\\n        {\\n          \\\"isCorrect\\\": boolean,\\n          \\\"explanation\\\": \\\"brief explanation of why it's correct or incorrect\\\",\\n          \\\"similarity\\\": \\\"percentage of similarity\\\",\\n          \\\"partialCredit\\\": \\\"percentage of points to award for close answers (0-100)\\\"\\n        }\");\n      const completion = await openai.chat.completions.create({\n        messages: [{\n          role: \"system\",\n          content: systemPrompt\n        }, {\n          role: \"user\",\n          content: prompt\n        }],\n        model: \"gpt-4\",\n        temperature: 0.1\n      });\n      return JSON.parse(completion.choices[0].message.content);\n    } catch (error) {\n      throw new Error('Failed to validate answer. Please try again.');\n    }\n  };\n  return retryWithExponentialBackoff(operation);\n};\n\n// Debug utilities\nexport const getDebugInfo = () => {\n  if (!DEBUG.enabled) return null;\n  return {\n    retryHistory: retryHistory.attempts,\n    circuitBreakerStatus: {\n      failures: circuitBreaker.failures,\n      isOpen: circuitBreaker.isOpen(),\n      lastFailure: circuitBreaker.lastFailure\n    },\n    currentRetryStrategy: updateRetryStrategy(),\n    errorStats: getErrorStats()\n  };\n};\n\n// Debug mode toggle\nexport const toggleDebugMode = function () {\n  var _options$enabled, _options$verbose, _options$logLevel, _options$retrySimulat;\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (!process.env.NODE_ENV === 'development') {\n    console.warn('Debug mode can only be toggled in development environment');\n    return;\n  }\n  DEBUG.enabled = (_options$enabled = options.enabled) !== null && _options$enabled !== void 0 ? _options$enabled : !DEBUG.enabled;\n  DEBUG.verbose = (_options$verbose = options.verbose) !== null && _options$verbose !== void 0 ? _options$verbose : DEBUG.verbose;\n  DEBUG.logLevel = (_options$logLevel = options.logLevel) !== null && _options$logLevel !== void 0 ? _options$logLevel : DEBUG.logLevel;\n  DEBUG.retrySimulation = (_options$retrySimulat = options.retrySimulation) !== null && _options$retrySimulat !== void 0 ? _options$retrySimulat : DEBUG.retrySimulation;\n  debugLog('info', 'Debug mode settings updated', DEBUG);\n};","map":{"version":3,"names":["OpenAI","DEBUG","enabled","process","env","REACT_APP_DEBUG_MODE","verbose","REACT_APP_DEBUG_VERBOSE","logLevel","REACT_APP_DEBUG_LEVEL","retrySimulation","REACT_APP_SIMULATE_RETRIES","RETRY_PATTERNS","AGGRESSIVE","maxRetries","baseDelay","backoffMultiplier","jitterMax","timeout","CONSERVATIVE","ADAPTIVE","initialMaxRetries","maxRetriesLimit","successThreshold","failureThreshold","adaptiveWindow","retryHistory","attempts","successes","failures","debugLog","level","message","data","arguments","length","undefined","timestamp","Date","toISOString","logLevels","indexOf","console","concat","_objectSpread","debugMode","updateRetryStrategy","recentAttempts","slice","successRate","filter","a","success","Math","max","min","circuitBreaker","lastFailure","threshold","resetTimeout","isOpen","timeSinceLastFailure","now","recordFailure","reset","openai","apiKey","REACT_APP_OPENAI_API_KEY","DIFFICULTY_MODIFIERS","EASY","description","popularity","temperature","MEDIUM","HARD","ERROR_TYPES","API_KEY","RATE_LIMIT","NETWORK","VALIDATION","TIMEOUT","SERVER","CONTENT_FILTER","QUOTA_EXCEEDED","UNKNOWN","errorStats","counts","lastOccurrence","retrySuccess","RETRY_CONFIG","timeoutMs","retryableStatuses","sleep","ms","Promise","resolve","setTimeout","getJitter","random","classifyError","error","_error$response","_error$response2","_error$response3","debug","status","response","type","stack","includes","logError","context","errorType","stats","REACT_APP_ERROR_TRACKING_ENABLED","calculateRetryDelay","attempt","exponentialDelay","pow","handleAPIError","retryCount","Error","retryPattern","push","shouldRetry","delay","name","err","getErrorStats","ERROR_TYPES_ENUM","getPhrase","category","difficulty","difficultyConfig","operation","systemPrompt","prompt","toLowerCase","completion","chat","completions","create","messages","role","content","model","JSON","parse","choices","requiredFields","field","retryWithExponentialBackoff","checkAnswer","userAnswer","correctAnswer","source","getDebugInfo","circuitBreakerStatus","currentRetryStrategy","toggleDebugMode","_options$enabled","_options$verbose","_options$logLevel","_options$retrySimulat","options","NODE_ENV","warn"],"sources":["/Users/eimis/test-server/react_projects/cloud-architecture-game/src/services/aiService.js"],"sourcesContent":["import OpenAI from 'openai';\n\n// Debug mode configuration\nconst DEBUG = {\n  enabled: process.env.REACT_APP_DEBUG_MODE === 'true',\n  verbose: process.env.REACT_APP_DEBUG_VERBOSE === 'true',\n  logLevel: process.env.REACT_APP_DEBUG_LEVEL || 'info',\n  retrySimulation: process.env.REACT_APP_SIMULATE_RETRIES === 'true'\n};\n\n// Enhanced retry patterns\nconst RETRY_PATTERNS = {\n  AGGRESSIVE: {\n    maxRetries: 5,\n    baseDelay: 500,\n    backoffMultiplier: 1.2,\n    jitterMax: 100,\n    timeout: 8000\n  },\n  CONSERVATIVE: {\n    maxRetries: 3,\n    baseDelay: 1000,\n    backoffMultiplier: 2,\n    jitterMax: 200,\n    timeout: 15000\n  },\n  ADAPTIVE: {\n    initialMaxRetries: 3,\n    maxRetriesLimit: 7,\n    baseDelay: 800,\n    successThreshold: 0.7,\n    failureThreshold: 0.3,\n    adaptiveWindow: 10 // Number of requests to consider for adaptation\n  }\n};\n\n// Retry history for adaptive pattern\nconst retryHistory = {\n  attempts: [],\n  successes: 0,\n  failures: 0\n};\n\nconst debugLog = (level, message, data = {}) => {\n  if (!DEBUG.enabled) return;\n  \n  const timestamp = new Date().toISOString();\n  const logLevels = ['error', 'warn', 'info', 'debug'];\n  \n  if (logLevels.indexOf(level) <= logLevels.indexOf(DEBUG.logLevel)) {\n    console[level](`[${timestamp}] ${message}`, {\n      ...data,\n      debugMode: true,\n      logLevel: level\n    });\n  }\n};\n\n// Adaptive retry strategy\nconst updateRetryStrategy = () => {\n  if (retryHistory.attempts.length < RETRY_PATTERNS.ADAPTIVE.adaptiveWindow) {\n    return RETRY_PATTERNS.CONSERVATIVE;\n  }\n\n  const recentAttempts = retryHistory.attempts.slice(-RETRY_PATTERNS.ADAPTIVE.adaptiveWindow);\n  const successRate = recentAttempts.filter(a => a.success).length / recentAttempts.length;\n\n  debugLog('info', 'Updating retry strategy', { successRate, recentAttempts });\n\n  if (successRate > RETRY_PATTERNS.ADAPTIVE.successThreshold) {\n    return {\n      ...RETRY_PATTERNS.CONSERVATIVE,\n      maxRetries: Math.max(2, RETRY_PATTERNS.CONSERVATIVE.maxRetries - 1)\n    };\n  } else if (successRate < RETRY_PATTERNS.ADAPTIVE.failureThreshold) {\n    return {\n      ...RETRY_PATTERNS.AGGRESSIVE,\n      maxRetries: Math.min(RETRY_PATTERNS.ADAPTIVE.maxRetriesLimit, \n                          RETRY_PATTERNS.AGGRESSIVE.maxRetries + 1)\n    };\n  }\n\n  return RETRY_PATTERNS.CONSERVATIVE;\n};\n\n// Circuit breaker implementation\nconst circuitBreaker = {\n  failures: 0,\n  lastFailure: null,\n  threshold: 5,\n  resetTimeout: 30000,\n  \n  isOpen() {\n    if (!this.lastFailure) return false;\n    const timeSinceLastFailure = Date.now() - this.lastFailure;\n    return this.failures >= this.threshold && timeSinceLastFailure < this.resetTimeout;\n  },\n  \n  recordFailure() {\n    this.failures++;\n    this.lastFailure = Date.now();\n    debugLog('warn', 'Circuit breaker failure recorded', { \n      failures: this.failures,\n      threshold: this.threshold \n    });\n  },\n  \n  reset() {\n    this.failures = 0;\n    this.lastFailure = null;\n    debugLog('info', 'Circuit breaker reset');\n  }\n};\n\nconst openai = new OpenAI({\n  apiKey: process.env.REACT_APP_OPENAI_API_KEY,\n});\n\nconst DIFFICULTY_MODIFIERS = {\n  EASY: {\n    description: \"well-known and popular quotes from the last 30 years\",\n    popularity: \"highly popular\",\n    maxRetries: 3,\n    temperature: 0.5\n  },\n  MEDIUM: {\n    description: \"moderately known quotes from the last 50 years\",\n    popularity: \"moderately known\",\n    maxRetries: 3,\n    temperature: 0.7\n  },\n  HARD: {\n    description: \"obscure or historical quotes from any time period\",\n    popularity: \"less known\",\n    maxRetries: 3,\n    temperature: 0.9\n  }\n};\n\n// Enhanced error types\nconst ERROR_TYPES = {\n  API_KEY: 'API_KEY_ERROR',\n  RATE_LIMIT: 'RATE_LIMIT_ERROR',\n  NETWORK: 'NETWORK_ERROR',\n  VALIDATION: 'VALIDATION_ERROR',\n  TIMEOUT: 'TIMEOUT_ERROR',\n  SERVER: 'SERVER_ERROR',\n  CONTENT_FILTER: 'CONTENT_FILTER_ERROR',\n  QUOTA_EXCEEDED: 'QUOTA_EXCEEDED_ERROR',\n  UNKNOWN: 'UNKNOWN_ERROR'\n};\n\n// Error tracking analytics\nconst errorStats = {\n  counts: {},\n  lastOccurrence: {},\n  retrySuccess: {},\n};\n\n// Sophisticated retry configuration\nconst RETRY_CONFIG = {\n  baseDelay: 1000,\n  maxRetries: 3,\n  timeoutMs: 10000,\n  backoffMultiplier: 1.5,\n  jitterMax: 200,\n  retryableStatuses: [429, 503, 502, 500],\n};\n\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n// Add jitter to avoid thundering herd problem\nconst getJitter = () => Math.random() * RETRY_CONFIG.jitterMax;\n\n// Enhanced error classification\nconst classifyError = (error) => {\n  // Log error for debugging\n  console.debug('Error details:', {\n    message: error.message,\n    status: error.response?.status,\n    type: error.type,\n    stack: error.stack,\n  });\n\n  if (error.message.includes('API key')) return ERROR_TYPES.API_KEY;\n  if (error.response?.status === 429) return ERROR_TYPES.RATE_LIMIT;\n  if (error.message.includes('network')) return ERROR_TYPES.NETWORK;\n  if (error.message.includes('timeout')) return ERROR_TYPES.TIMEOUT;\n  if (error.response?.status >= 500) return ERROR_TYPES.SERVER;\n  if (error.message.includes('content filter')) return ERROR_TYPES.CONTENT_FILTER;\n  if (error.message.includes('quota')) return ERROR_TYPES.QUOTA_EXCEEDED;\n  if (error.message.includes('Invalid API response')) return ERROR_TYPES.VALIDATION;\n  return ERROR_TYPES.UNKNOWN;\n};\n\n// Error logging with timestamp and context\nconst logError = (error, context = {}) => {\n  const errorType = classifyError(error);\n  const timestamp = new Date().toISOString();\n  \n  // Update error statistics\n  errorStats.counts[errorType] = (errorStats.counts[errorType] || 0) + 1;\n  errorStats.lastOccurrence[errorType] = timestamp;\n\n  // Log to console with structured format\n  console.error('Game Error:', {\n    type: errorType,\n    timestamp,\n    message: error.message,\n    context,\n    stats: errorStats.counts[errorType],\n    stack: error.stack,\n  });\n\n  // Could be extended to send to external error tracking service\n  if (process.env.REACT_APP_ERROR_TRACKING_ENABLED === 'true') {\n    // Example: sendToErrorTracking(error, context);\n  }\n};\n\n// Sophisticated retry strategy with exponential backoff and jitter\nconst calculateRetryDelay = (attempt) => {\n  const exponentialDelay = RETRY_CONFIG.baseDelay * Math.pow(RETRY_CONFIG.backoffMultiplier, attempt);\n  return exponentialDelay + getJitter();\n};\n\n// Enhanced error handling with retry strategy\nexport const handleAPIError = async (error, retryCount = 0, context = {}) => {\n  if (DEBUG.enabled) {\n    debugLog('error', 'API Error occurred', { error, retryCount, context });\n  }\n\n  // Check circuit breaker\n  if (circuitBreaker.isOpen()) {\n    throw new Error('Service temporarily unavailable. Please try again later.');\n  }\n\n  const errorType = classifyError(error);\n  const retryPattern = updateRetryStrategy();\n\n  if (DEBUG.retrySimulation) {\n    debugLog('info', 'Simulating retry scenario', { errorType, retryPattern });\n  }\n\n  try {\n    // ... existing error handling logic ...\n\n    // Record success in retry history\n    retryHistory.attempts.push({ success: true, timestamp: Date.now() });\n    circuitBreaker.reset();\n\n    return {\n      shouldRetry: true,\n      delay: calculateRetryDelay(retryCount, retryPattern),\n      errorType,\n      retryCount: retryCount + 1,\n      retryPattern: retryPattern.name\n    };\n  } catch (err) {\n    // Record failure in retry history\n    retryHistory.attempts.push({ success: false, timestamp: Date.now() });\n    circuitBreaker.recordFailure();\n\n    if (DEBUG.enabled) {\n      debugLog('error', 'Retry attempt failed', { \n        attempt: retryCount + 1,\n        maxRetries: retryPattern.maxRetries,\n        error: err\n      });\n    }\n\n    throw err;\n  }\n};\n\n// Export error statistics for monitoring\nexport const getErrorStats = () => ({\n  ...errorStats,\n  timestamp: new Date().toISOString(),\n});\n\n// Export error types for external use\nexport const ERROR_TYPES_ENUM = ERROR_TYPES;\n\nexport const getPhrase = async (category, difficulty = 'MEDIUM') => {\n  const difficultyConfig = DIFFICULTY_MODIFIERS[difficulty];\n  \n  const operation = async () => {\n    try {\n      const systemPrompt = `You are a game master for 'Legendary Lines'. \n        Generate ${difficultyConfig.popularity} content for the ${category} category.\n        Focus on ${difficultyConfig.description}.`;\n      \n      const prompt = `Generate a ${difficulty.toLowerCase()} difficulty ${category.toLowerCase()} quote or phrase.\n        The response must be in this exact JSON format:\n        {\n          \"phrase\": \"the actual quote or phrase\",\n          \"source\": \"where it's from\",\n          \"year\": YYYY,\n          \"hint\": \"a subtle hint without giving away the answer\",\n          \"difficulty\": \"${difficulty}\",\n          \"category\": \"${category}\"\n        }`;\n\n      const completion = await openai.chat.completions.create({\n        messages: [\n          { role: \"system\", content: systemPrompt },\n          { role: \"user\", content: prompt }\n        ],\n        model: \"gpt-4\",\n        temperature: difficultyConfig.temperature,\n      });\n\n      const response = JSON.parse(completion.choices[0].message.content);\n      \n      // Validate response format\n      const requiredFields = ['phrase', 'source', 'year', 'hint', 'difficulty', 'category'];\n      for (const field of requiredFields) {\n        if (!response[field]) {\n          throw new Error(`Invalid API response: missing ${field}`);\n        }\n      }\n\n      return response;\n    } catch (error) {\n      if (error.message.includes('Invalid API response')) {\n        throw new Error('Failed to generate valid phrase. Please try again.');\n      }\n      throw error;\n    }\n  };\n\n  return retryWithExponentialBackoff(\n    operation,\n    difficultyConfig.maxRetries\n  );\n};\n\nexport const checkAnswer = async (userAnswer, correctAnswer, category) => {\n  const operation = async () => {\n    try {\n      const systemPrompt = `You are an answer validator for the 'Legendary Lines' game.`;\n      \n      const prompt = `Compare these answers for a ${category} quote:\n        User's answer: \"${userAnswer}\"\n        Correct answer: \"${correctAnswer.source}\"\n        Difficulty level: ${correctAnswer.difficulty}\n        \n        Consider variations in naming and common abbreviations.\n        For harder difficulty levels, be more lenient with partial matches.\n        Return a JSON response in this format:\n        {\n          \"isCorrect\": boolean,\n          \"explanation\": \"brief explanation of why it's correct or incorrect\",\n          \"similarity\": \"percentage of similarity\",\n          \"partialCredit\": \"percentage of points to award for close answers (0-100)\"\n        }`;\n\n      const completion = await openai.chat.completions.create({\n        messages: [\n          { role: \"system\", content: systemPrompt },\n          { role: \"user\", content: prompt }\n        ],\n        model: \"gpt-4\",\n        temperature: 0.1,\n      });\n\n      return JSON.parse(completion.choices[0].message.content);\n    } catch (error) {\n      throw new Error('Failed to validate answer. Please try again.');\n    }\n  };\n\n  return retryWithExponentialBackoff(operation);\n}; \n\n// Debug utilities\nexport const getDebugInfo = () => {\n  if (!DEBUG.enabled) return null;\n  \n  return {\n    retryHistory: retryHistory.attempts,\n    circuitBreakerStatus: {\n      failures: circuitBreaker.failures,\n      isOpen: circuitBreaker.isOpen(),\n      lastFailure: circuitBreaker.lastFailure\n    },\n    currentRetryStrategy: updateRetryStrategy(),\n    errorStats: getErrorStats()\n  };\n};\n\n// Debug mode toggle\nexport const toggleDebugMode = (options = {}) => {\n  if (!process.env.NODE_ENV === 'development') {\n    console.warn('Debug mode can only be toggled in development environment');\n    return;\n  }\n\n  DEBUG.enabled = options.enabled ?? !DEBUG.enabled;\n  DEBUG.verbose = options.verbose ?? DEBUG.verbose;\n  DEBUG.logLevel = options.logLevel ?? DEBUG.logLevel;\n  DEBUG.retrySimulation = options.retrySimulation ?? DEBUG.retrySimulation;\n\n  debugLog('info', 'Debug mode settings updated', DEBUG);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}